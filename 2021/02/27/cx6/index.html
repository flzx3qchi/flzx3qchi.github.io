<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    操作系统真象还原&lt;第六部分&gt; |  Hexo
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      <section class="outer">
  <article id="post-cx6" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  操作系统真象还原&lt;第六部分&gt;
</h1>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/02/27/cx6/" class="article-date">
  <time datetime="2021-02-26T16:00:00.000Z" itemprop="datePublished">2021-02-27</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">9k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">42 min</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>(｡･∀･)ﾉﾞ嗨起来！！！</p>
<a id="more"></a>

<h1 id="内存管理系统"><a href="#内存管理系统" class="headerlink" title="内存管理系统"></a>内存管理系统</h1><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>make 命令可以自动找出变更的文件，并根据依赖关系，找出受变更文件影响的其它相关文件，然后对这些文件按照规则进行单独处理。</p>
<p>makefile 文件是 make 程序的搭档，它们发现某个文件更新后，只编译该文件和受该文件影响的相关文件，其它不受影响的文件不重新编译，从而提高了编译效率。</p>
<h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>make 规定，当规则中不存在依赖文件时，这个目标文件名就称为伪目标。</p>
<p>为了避免伪目标和真实目标文件同名的情况，可以用关键字“.PHONY”来修饰伪目标，格式为”.PHONY:伪目标名”。这样不管与伪目标同名的文件是否存在，make 照样执行伪目标处的命令。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13223102057/0" alt="image-20210225094704080"></p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13223102108/0" alt="image-20210225094734587"></p>
<h3 id="自定义变量与系统变量"><a href="#自定义变量与系统变量" class="headerlink" title="自定义变量与系统变量"></a>自定义变量与系统变量</h3><p>makefile 中定义变量的格式是: 变量名 = 值(字符串)。</p>
<p>变量引用的格式: $(变量名)。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13223102178/0" alt="image-20210225094832713"></p>
<h3 id="隐含规则"><a href="#隐含规则" class="headerlink" title="隐含规则"></a>隐含规则</h3><p>在编写规则时，若一行写不下，可以在行尾添加反斜杠字符 ‘\’，这样下一行的内容便被认为是同一行。</p>
<p>makefile 中用 # 来单行注释。</p>
<p>隐含规则：对于一些使用频率非常高的规则，make 把它们当成是默认的，不需要显式地写出来，当用户未在 makefile 中显式定义规则时，将默认使用隐含规则进行推导。</p>
<p>隐含规则只限于那些编译过程中基本固定的依赖关系，比如 C 语言代码文件扩展名为 .c，编译生成的目标文件扩展名是 .o。</p>
<p>常见的部分语言程序的隐含规则：</p>
<ul>
<li><p>C 程序</p>
<p>x.o 的生成依赖于 x.c</p>
</li>
<li><p>C++ 程序</p>
<p>x.o 的生成依赖于 x.cc 或者 x.C</p>
</li>
<li><p>Pascal 程序</p>
<p>x.o 的生成依赖于 x.p</p>
</li>
</ul>
<h3 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h3><p>@，表示规则中的目标文件名集合，如果存在多个目标文件，@ 则表示其中每一个文件名。</p>
<p>$&lt;，表示规则中依赖文件的第 1 个文件。</p>
<p>$^，表示规则中所有依赖文件的集合，如果集合中有重复的文件，会自动去重。</p>
<p>$?，表示规则中，所有比目标文件 mtime 更新的依赖文件集合。</p>
<h3 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h3><p>% 用来匹配任意多个非空字符。比如 %.o 代表所有以 .o 为结尾的文件，g%.o 是以字符 g 开头的所有以 .o 为结尾的文件，make 会拿这个字符串模式去文件系统上查找文件，默认为当前路径下。</p>
<p>之后我们都用 <strong>makefile</strong> 来编译程序了</p>
<p>新增了一些编译选项并且把ubantu的终端修改为了bash，具体如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">BUILD_DIR &#x3D; .&#x2F;build</span><br><span class="line">ENTRY_POINT &#x3D; 0xc0001500</span><br><span class="line">AS &#x3D; nasm</span><br><span class="line">CC &#x3D; gcc</span><br><span class="line">LD &#x3D; ld</span><br><span class="line">LIB &#x3D; -I lib&#x2F; -I lib&#x2F;kernel&#x2F; -I lib&#x2F;user&#x2F; -I kernel&#x2F; -I device&#x2F;</span><br><span class="line">ASFLAGS &#x3D; -f elf</span><br><span class="line">CFLAGS &#x3D; -m32 -fno-stack-protector -Wall $(LIB) -c -fno-builtin -W -Wstrict-prototypes \</span><br><span class="line">         -Wmissing-prototypes </span><br><span class="line">LDFLAGS &#x3D; -m elf_i386 -Ttext $(ENTRY_POINT) -e main -Map $(BUILD_DIR)&#x2F;kernel.map</span><br><span class="line">OBJS &#x3D; $(BUILD_DIR)&#x2F;main.o $(BUILD_DIR)&#x2F;init.o $(BUILD_DIR)&#x2F;interrupt.o \</span><br><span class="line">      $(BUILD_DIR)&#x2F;timer.o $(BUILD_DIR)&#x2F;kernel.o $(BUILD_DIR)&#x2F;print.o \</span><br><span class="line">      $(BUILD_DIR)&#x2F;debug.o</span><br><span class="line"></span><br><span class="line">##############     c代码编译     ###############</span><br><span class="line">$(BUILD_DIR)&#x2F;main.o: kernel&#x2F;main.c lib&#x2F;kernel&#x2F;print.h \</span><br><span class="line">        lib&#x2F;stdint.h kernel&#x2F;init.h</span><br><span class="line">	$(CC) $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)&#x2F;init.o: kernel&#x2F;init.c kernel&#x2F;init.h lib&#x2F;kernel&#x2F;print.h \</span><br><span class="line">        lib&#x2F;stdint.h kernel&#x2F;interrupt.h device&#x2F;timer.h</span><br><span class="line">	$(CC) $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)&#x2F;interrupt.o: kernel&#x2F;interrupt.c kernel&#x2F;interrupt.h \</span><br><span class="line">        lib&#x2F;stdint.h kernel&#x2F;global.h lib&#x2F;kernel&#x2F;io.h lib&#x2F;kernel&#x2F;print.h</span><br><span class="line">	$(CC) $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)&#x2F;timer.o: device&#x2F;timer.c device&#x2F;timer.h lib&#x2F;stdint.h\</span><br><span class="line">         lib&#x2F;kernel&#x2F;io.h lib&#x2F;kernel&#x2F;print.h</span><br><span class="line">	$(CC) $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)&#x2F;debug.o: kernel&#x2F;debug.c kernel&#x2F;debug.h \</span><br><span class="line">        lib&#x2F;kernel&#x2F;print.h lib&#x2F;stdint.h kernel&#x2F;interrupt.h</span><br><span class="line">	$(CC) $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">##############    汇编代码编译    ###############</span><br><span class="line">$(BUILD_DIR)&#x2F;kernel.o: kernel&#x2F;kernel.S</span><br><span class="line">	$(AS) $(ASFLAGS) $&lt; -o $@</span><br><span class="line">$(BUILD_DIR)&#x2F;print.o: lib&#x2F;kernel&#x2F;print.S</span><br><span class="line">	$(AS) $(ASFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">##############    链接所有目标文件    #############</span><br><span class="line">$(BUILD_DIR)&#x2F;kernel.bin: $(OBJS)</span><br><span class="line">	$(LD) $(LDFLAGS) $^ -o $@</span><br><span class="line"></span><br><span class="line">.PHONY : mk_dir hd clean all</span><br><span class="line"></span><br><span class="line"># ubantu中需要将dash修改为bash运行</span><br><span class="line"># ls -al &#x2F;bin&#x2F;sh若结果为&#x2F;bin&#x2F;sh -&gt; dash</span><br><span class="line"># 执行sudo dpkg-reconfigure dash选择No即可</span><br><span class="line">mk_dir:</span><br><span class="line">	if [[ ! -d $(BUILD_DIR) ]];then mkdir $(BUILD_DIR);fi</span><br><span class="line"></span><br><span class="line">hd:</span><br><span class="line">	dd if&#x3D;$(BUILD_DIR)&#x2F;kernel.bin \</span><br><span class="line">           of&#x3D;&#x2F;home&#x2F;fyz&#x2F;sc&#x2F;bochs-2.6.2&#x2F;hd60M.img \</span><br><span class="line">           bs&#x3D;512 count&#x3D;200 seek&#x3D;9 conv&#x3D;notrunc</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	cd $(BUILD_DIR) &amp;&amp; rm -f .&#x2F;*</span><br><span class="line"></span><br><span class="line">build: $(BUILD_DIR)&#x2F;kernel.bin</span><br><span class="line"></span><br><span class="line">all: mk_dir build hd</span><br></pre></td></tr></table></figure>

<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>我们需要更新 <code>interrupt.c</code>和 <code>interrupt.h</code> 来实现开、关中断的函数</p>
<p> <code>interrupt.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"global.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"io.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"interrupt.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> IDT_DESC_CNT 0x21  <span class="comment">//支持的中断数</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PIC_M_CTRL 0x20</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PIC_M_DATA 0x21</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PIC_S_CTRL 0xa0</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PIC_S_DATA 0xa1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EFLAGS_IF 0x00000200</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> GET_EFLAGS(EFLAG_VAR) asm volatile (<span class="meta-string">"pushfl; popl %0"</span> : <span class="meta-string">"=g"</span> (EFLAG_VAR))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断门描述符结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gate_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> func_offset_low_word;</span><br><span class="line">    <span class="keyword">uint16_t</span> selector;</span><br><span class="line">    <span class="keyword">uint8_t</span> dcount; <span class="comment">//此项为双字计数字段，是门描述符中的第 4 字节</span></span><br><span class="line">                    <span class="comment">//此项固定值，不用考虑</span></span><br><span class="line">    <span class="keyword">uint8_t</span> attribute;</span><br><span class="line">    <span class="keyword">uint16_t</span> func_offset_high_word;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断的名称.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">char</span>* intr_name[IDT_DESC_CNT];   <span class="comment">//用于保存异常的名字</span></span><br><span class="line">intr_handler idt_table[IDT_DESC_CNT];</span><br><span class="line"><span class="comment">//定义中断处理程序数组，在 kernel.S 中定义的 intrXXentry </span></span><br><span class="line"><span class="comment">//只是中断处理程序的入口，最终调用的是 ide_table 中的处理程序</span></span><br><span class="line"><span class="keyword">extern</span> intr_handler intr_entry_table[IDT_DESC_CNT];</span><br><span class="line"><span class="comment">//声明引用定义在 kernel.S 中的中断处理函数入口数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_custom_handler_name</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_idt_desc</span><span class="params">(struct gate_desc* p_gdesc, <span class="keyword">uint8_t</span> attr, intr_handler function)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_desc</span> <span class="title">idt</span>[<span class="title">IDT_DESC_CNT</span>];</span>  <span class="comment">// idt 是中断描述符表</span></span><br><span class="line">                                            <span class="comment">//本质上就是个中断门描述符数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开中断并返回之前的状态.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">enum</span> intr_status <span class="title">intr_enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> intr_status old_status;</span><br><span class="line">    <span class="keyword">if</span> (INTR_ON == intr_get_status()) &#123;</span><br><span class="line">        old_status = INTR_ON;</span><br><span class="line">	<span class="keyword">return</span> old_status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    old_status = INTR_OFF;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"sti"</span>)</span></span>;  <span class="comment">// 开中断，sti 指令将 IF 位置 1</span></span><br><span class="line">    <span class="keyword">return</span> old_status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关中断并返回之前的状态.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">enum</span> intr_status <span class="title">intr_disable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> intr_status old_status;</span><br><span class="line">    <span class="keyword">if</span> (INTR_OFF == intr_get_status()) &#123;</span><br><span class="line">        old_status = INTR_OFF;</span><br><span class="line">        <span class="keyword">return</span> old_status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    old_status = INTR_ON;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"cli"</span> : : : <span class="string">"memory"</span>)</span></span>;  <span class="comment">// 关中断，cli 指令将 IF 位置 0</span></span><br><span class="line">    <span class="keyword">return</span> old_status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 将中断状态设置为 status </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">enum</span> intr_status <span class="title">intr_set_status</span><span class="params">(<span class="keyword">enum</span> intr_status status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &amp; INTR_ON ? intr_enable() : intr_disable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取中断状态.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">enum</span> intr_status <span class="title">intr_get_status</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> eflags = <span class="number">0</span>;</span><br><span class="line">    GET_EFLAGS(eflags);</span><br><span class="line">    <span class="keyword">return</span> (EFLAGS_IF &amp; eflags) ? INTR_ON : INTR_OFF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用的中断处理函数.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">general_intr_handler</span><span class="params">(<span class="keyword">uint8_t</span> vec_nr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vec_nr == <span class="number">0x27</span> || vec_nr == <span class="number">0x2f</span>) &#123;</span><br><span class="line">        <span class="comment">// 伪中断，无需处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    put_str(<span class="string">"int vector: 0x"</span>);</span><br><span class="line">    put_int(vec_nr);</span><br><span class="line">    put_char(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用(默认)的异常/中断处理器注册.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exception_handler_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; IDT_DESC_CNT; i++) &#123;</span><br><span class="line">        idt_table[i] = general_intr_handler; </span><br><span class="line">        <span class="comment">//idt_table 数组中的函数是在进入中断后根据中断向量号调用的</span></span><br><span class="line">        intr_name[i] = <span class="string">"unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_custom_handler_name();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置需要自定义的中断名称.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_custom_handler_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    intr_name[<span class="number">0</span>] = <span class="string">"#DE Divide Error"</span>;</span><br><span class="line">    intr_name[<span class="number">1</span>] = <span class="string">"#DB Debug Exception"</span>;</span><br><span class="line">    intr_name[<span class="number">2</span>] = <span class="string">"NMI Interrupt"</span>;</span><br><span class="line">    intr_name[<span class="number">3</span>] = <span class="string">"#BP Breakpoint Exception"</span>;</span><br><span class="line">    intr_name[<span class="number">4</span>] = <span class="string">"#OF Overflow Exception"</span>;</span><br><span class="line">    intr_name[<span class="number">5</span>] = <span class="string">"#BR BOUND Range Exceeded Exception"</span>;</span><br><span class="line">    intr_name[<span class="number">6</span>] = <span class="string">"#UD Invalid Opcode Exception"</span>;</span><br><span class="line">    intr_name[<span class="number">7</span>] = <span class="string">"#NM Device Not Available Exception"</span>;</span><br><span class="line">    intr_name[<span class="number">8</span>] = <span class="string">"#DF Double Fault Exception"</span>;</span><br><span class="line">    intr_name[<span class="number">9</span>] = <span class="string">"Coprocessor Segment Overrun"</span>;</span><br><span class="line">    intr_name[<span class="number">10</span>] = <span class="string">"#TS Invalid TSS Exception"</span>;</span><br><span class="line">    intr_name[<span class="number">11</span>] = <span class="string">"#NP Segment Not Present"</span>;</span><br><span class="line">    intr_name[<span class="number">12</span>] = <span class="string">"#SS Stack Fault Exception"</span>;</span><br><span class="line">    intr_name[<span class="number">13</span>] = <span class="string">"#GP General Protection Exception"</span>;</span><br><span class="line">    intr_name[<span class="number">14</span>] = <span class="string">"#PF Page-Fault Exception"</span>;</span><br><span class="line">    intr_name[<span class="number">16</span>] = <span class="string">"#MF 0x87 FPU Floating-Point Error"</span>;</span><br><span class="line">    intr_name[<span class="number">17</span>] = <span class="string">"#AC Alignment Check Exception"</span>;</span><br><span class="line">    intr_name[<span class="number">18</span>] = <span class="string">"#MC Machine-Check Exception"</span>;</span><br><span class="line">    intr_name[<span class="number">19</span>] = <span class="string">"#XF SIMD Floating-Point Exception"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建中断门描述符.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_idt_desc</span><span class="params">(struct gate_desc* p_gdesc, <span class="keyword">uint8_t</span> attr, intr_handler function)</span> </span>&#123;</span><br><span class="line">    p_gdesc-&gt;func_offset_low_word = (<span class="keyword">uint32_t</span>) function &amp; <span class="number">0x0000FFFF</span>;</span><br><span class="line">    p_gdesc-&gt;selector = SELECTOR_K_CODE;</span><br><span class="line">    p_gdesc-&gt;dcount = <span class="number">0</span>;</span><br><span class="line">    p_gdesc-&gt;attribute = attr;</span><br><span class="line">    p_gdesc-&gt;func_offset_high_word = ((<span class="keyword">uint32_t</span>) function &amp; <span class="number">0xFFFF0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化中断描述符表.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">idt_desc_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; IDT_DESC_CNT; i++) &#123;</span><br><span class="line">        make_idt_desc(&amp;idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    put_str(<span class="string">"idt_desc_init done.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pic_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化主片</span></span><br><span class="line">    outb(PIC_M_CTRL, <span class="number">0x11</span>); <span class="comment">// ICW1: 边沿触发,级联 8259, 需要 ICW4</span></span><br><span class="line">    outb(PIC_M_DATA, <span class="number">0x20</span>); <span class="comment">// ICW2: 起始中断向量号为 0x20</span></span><br><span class="line">                            <span class="comment">// 也就是 IR[0-7] 为 0x20 ～ 0x27</span></span><br><span class="line">    outb(PIC_M_DATA, <span class="number">0x04</span>); <span class="comment">// ICW3: IR2 接从片</span></span><br><span class="line">    outb(PIC_M_DATA, <span class="number">0x01</span>); <span class="comment">// ICW4: 8086 模式, 正常 EOI</span></span><br><span class="line"></span><br><span class="line">    outb(PIC_S_CTRL, <span class="number">0x11</span>); <span class="comment">// ICW1: 边沿触发,级联 8259, 需要 ICW4</span></span><br><span class="line">    outb(PIC_S_DATA, <span class="number">0x28</span>); <span class="comment">// ICW2: 起始中断向量号为 0x28</span></span><br><span class="line">                            <span class="comment">// 也就是 IR[8-15]为 0x28 ～ 0x2F</span></span><br><span class="line">    outb(PIC_S_DATA, <span class="number">0x02</span>); <span class="comment">// ICW3: 设置从片连接到主片的 IR2 引脚</span></span><br><span class="line">    outb(PIC_S_DATA, <span class="number">0x01</span>); <span class="comment">// ICW4: 8086 模式, 正常 EOI</span></span><br><span class="line">    <span class="comment">/*打开主片上 IR0,也就是目前只接受时钟产生的中断 */</span></span><br><span class="line">    outb(PIC_M_DATA, <span class="number">0xfe</span>);</span><br><span class="line">    outb(PIC_S_DATA, <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">    put_str(<span class="string">"pic_init done.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*完成有关中断的所有初始化工作*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idt_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    put_str(<span class="string">"idt_init start.\n"</span>);</span><br><span class="line">    idt_desc_init();  <span class="comment">// 初始化中断描述符表</span></span><br><span class="line">    exception_handler_init();</span><br><span class="line">    pic_init();       <span class="comment">// 初始化 8259A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载idt</span></span><br><span class="line">    <span class="keyword">uint64_t</span> idt_operand = ((<span class="keyword">sizeof</span>(idt) - <span class="number">1</span>) | ((<span class="keyword">uint64_t</span>) ((<span class="keyword">uint32_t</span>) idt &lt;&lt; <span class="number">16</span>)));</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"lidt %0"</span> : : <span class="string">"m"</span> (idt_operand))</span></span>;</span><br><span class="line">    put_str(<span class="string">"idt_init done.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>interrupt.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> _KERNEL_INTERRUPT_H</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _KERNEL_INTERRUPT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* intr_handler;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idt_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断状态.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">enum</span> intr_status &#123;  </span><br><span class="line">    INTR_OFF,       </span><br><span class="line">    INTR_ON</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">enum</span> intr_status <span class="title">intr_get_status</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">enum</span> intr_status <span class="title">intr_set_status</span><span class="params">(<span class="keyword">enum</span> intr_status)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">enum</span> intr_status <span class="title">intr_enable</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">enum</span> intr_status <span class="title">intr_disable</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>为了调试方便我们新增加了断言(ASSERT)，其核心思想是若断言通过则什么都不做，若不通过则用循环实现等待，打印错误信息，见<code>debug.c</code>和<code>debug.h</code></p>
<p><code>debug.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"debug.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"kernel/print.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"interrupt.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">panic_spin</span><span class="params">(<span class="keyword">char</span>* filename, <span class="keyword">int</span> <span class="built_in">line</span>, <span class="keyword">const</span> <span class="keyword">char</span>* func, <span class="keyword">const</span> <span class="keyword">char</span>* condition)</span> </span>&#123;</span><br><span class="line">    intr_disable();</span><br><span class="line"></span><br><span class="line">    put_str(<span class="string">"Something wrong..."</span>);</span><br><span class="line">    </span><br><span class="line">    put_str(<span class="string">"FileName: "</span>);</span><br><span class="line">    put_str(filename);</span><br><span class="line">    put_char(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">    put_str(<span class="string">"Line: "</span>);</span><br><span class="line">    put_int(<span class="built_in">line</span>);</span><br><span class="line">    put_char(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">    put_str(<span class="string">"Function: "</span>);</span><br><span class="line">    put_str(func);</span><br><span class="line">    put_char(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">    put_str(<span class="string">"Condition: "</span>);</span><br><span class="line">    put_str(condition);</span><br><span class="line">    put_char(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>debug.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> _KERNEL_DEBUG_H</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _KERNEL_DEBUG_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">panic_spin</span><span class="params">(<span class="keyword">char</span>* filename, <span class="keyword">int</span> <span class="built_in">line</span>, <span class="keyword">const</span> <span class="keyword">char</span>* func, <span class="keyword">const</span> <span class="keyword">char</span>* condition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当断言被触发时调用.</span></span><br><span class="line"><span class="comment"> * _FILE_: 内置宏,表示调用的文件名</span></span><br><span class="line"><span class="comment"> * _LINE_: 内置宏,被编译文件的行号</span></span><br><span class="line"><span class="comment"> * _func_: 内置宏: 被编译的函数名</span></span><br><span class="line"><span class="comment"> * _VA_ARGS_: 函数调用参数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PANIC(...) panic_spin (__FILE__, __LINE__, __func__, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">define</span> ASSERT(CONDITION) ((void) 0)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">define</span> ASSERT(CONDITION) \</span></span><br><span class="line">    <span class="keyword">if</span> (CONDITION) &#123; \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">        PANIC(#CONDITION); \</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>当前目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── boot</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── boot.inc</span><br><span class="line">│   ├── loader.bin</span><br><span class="line">│   ├── loader.S</span><br><span class="line">│   ├── mbr.bin</span><br><span class="line">│   └── mbr.S</span><br><span class="line">├── build</span><br><span class="line">│   ├── init.o</span><br><span class="line">│   ├── interrupt.o</span><br><span class="line">│   ├── kernel.bin</span><br><span class="line">│   ├── kernel.o</span><br><span class="line">│   ├── main.o</span><br><span class="line">│   ├── print.o</span><br><span class="line">│   └── timer.o</span><br><span class="line">│   └── debug.o</span><br><span class="line">├── device</span><br><span class="line">│   ├── timer.c</span><br><span class="line">│   └── timer.h</span><br><span class="line">├── kernel</span><br><span class="line">│   ├── global.h</span><br><span class="line">│   ├── init.c</span><br><span class="line">│   ├── init.h</span><br><span class="line">│   ├── interrupt.c</span><br><span class="line">│   ├── interrupt.h</span><br><span class="line">│   ├── kernel.S</span><br><span class="line">│   └── main.c</span><br><span class="line">│   └── debug.c</span><br><span class="line">│   └── debug.h</span><br><span class="line">└── lib</span><br><span class="line">    ├── kernel</span><br><span class="line">    │   ├── io.h</span><br><span class="line">    │   ├── print.h</span><br><span class="line">    │   ├── print.o</span><br><span class="line">    │   └── print.S</span><br><span class="line">    ├── stdint.h</span><br><span class="line">    └── user</span><br></pre></td></tr></table></figure>

<p><code>main.c</code>中对其进行测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"init.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"debug.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line">   ASSERT(<span class="number">1</span>==<span class="number">2</span>); <span class="comment">// 测试断言</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--sudo make all</span><br><span class="line">--sudo bin&#x2F;bochs -f bochsrc.disk</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13223102221/0" alt="image-20210225102247898"> </p>
<h2 id="实现字符串操作函数"><a href="#实现字符串操作函数" class="headerlink" title="实现字符串操作函数"></a>实现字符串操作函数</h2><p>在lib目录下用<code>string.c</code>实现对字符串的一些操作函数，比较好理解就不多解释了，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"global.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"debug.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同C类库同名函数.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memset</span><span class="params">(<span class="keyword">void</span>* address, <span class="keyword">uint8_t</span> value, <span class="keyword">uint32_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    ASSERT(address != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint8_t</span>* addr = (<span class="keyword">uint8_t</span>*) address;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">size</span>-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *addr++ = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存拷贝.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">uint32_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    ASSERT(dst != <span class="literal">NULL</span> &amp;&amp; src != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint8_t</span>* _dst = (<span class="keyword">uint8_t</span>*) dst;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span>* _src = (<span class="keyword">uint8_t</span>*) src;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">size</span>-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *_dst++ = _src++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串比较,如果左边大于右边,返回1,相等返回0,否则-1.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* left, <span class="keyword">const</span> <span class="keyword">void</span>* right, <span class="keyword">uint32_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    ASSERT(left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span>* _left = (<span class="keyword">uint8_t</span>*) left;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span>* _right = (<span class="keyword">uint8_t</span>*) right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">size</span>-- &gt; <span class="number">0</span> &amp;&amp; *_left++ == *_right);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (*_left &gt; *_right ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span> </span>&#123;</span><br><span class="line">    ASSERT(dst != <span class="literal">NULL</span> &amp;&amp; src != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* head = dst;</span><br><span class="line">    <span class="keyword">while</span> ((*dst++ = *src++));</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    ASSERT(str != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str++) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果左边大于右边返回1.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* left, <span class="keyword">const</span> <span class="keyword">char</span>* right)</span> </span>&#123;</span><br><span class="line">    ASSERT(left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*left != <span class="number">0</span> &amp;&amp; *left == *right) &#123;</span><br><span class="line">        ++left;</span><br><span class="line">        ++right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (*left &lt; *right ? <span class="number">-1</span> : *left &gt; *right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">uint8_t</span> c)</span> </span>&#123;</span><br><span class="line">    ASSERT(str != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> item;</span><br><span class="line">    <span class="keyword">while</span> ((item = *str) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item == c) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">char</span>*) str;</span><br><span class="line">        &#125;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倒序查找.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strrchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">uint8_t</span> c)</span> </span>&#123;</span><br><span class="line">    ASSERT(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* last_pos = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> item;</span><br><span class="line">    <span class="keyword">while</span> ((item = *str) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item == c) &#123;</span><br><span class="line">            last_pos = str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last_pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串拼接.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span> </span>&#123;</span><br><span class="line">    ASSERT(dst != <span class="literal">NULL</span> &amp;&amp; src != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* head = dst;</span><br><span class="line">    <span class="keyword">while</span> (*dst++);</span><br><span class="line">    --dst;</span><br><span class="line">    <span class="keyword">while</span> ((*dst++ = *src++));</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计制定的字符在字符串中出现的次数.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">strchrs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">uint8_t</span> c)</span> </span>&#123;</span><br><span class="line">    ASSERT(str != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> item;</span><br><span class="line">    <span class="keyword">while</span> ((item = *str) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item == c) &#123;</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>string.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> _LIB_STRING_H</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _LIB_STRING_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"global.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"debug.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memset</span><span class="params">(<span class="keyword">void</span>* address, <span class="keyword">uint8_t</span> value, <span class="keyword">uint32_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">uint32_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* left, <span class="keyword">const</span> <span class="keyword">void</span>* right, <span class="keyword">uint32_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* left, <span class="keyword">const</span> <span class="keyword">char</span>* right)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">uint8_t</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strrchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">uint8_t</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">strchrs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">uint8_t</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h2 id="位图-bitmap"><a href="#位图-bitmap" class="headerlink" title="位图 bitmap"></a>位图 bitmap</h2><h3 id="位图简介"><a href="#位图简介" class="headerlink" title="位图简介"></a>位图简介</h3><p>位图包含两个概念：位和图。</p>
<p>位是指 bit，即字节中的位，1 字节中有 8 个位。图是指 map，就是映射的意思，映射。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13223102269/0" alt="image-20210225110016024"> </p>
<p>总结一下，位图相当于一组资源的映射。位图中的每一位和被管理的单位资源都是一对一的关系，故位图主要用于管理容量较大的资源。</p>
<p>位图用于实现资源管理，相当于一张表，表中为1表示占用，为0表示空闲，之后我们将其用来管理内存</p>
<h3 id="位图的实现"><a href="#位图的实现" class="headerlink" title="位图的实现"></a>位图的实现</h3><p>在<code>lib/kernel</code>目录下新增<code>bitmap.h</code>与<code>bitmap.c</code>，代码如下，bitmap结构比较简单，只有两个成员：指针<strong>bits</strong> 和 位图的字节长度<strong>btmp_bytes_len</strong></p>
<p><code>bitmap.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIB_KERNEL_BITMAP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LIB_KERNEL_BITMAP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"global.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> BITMAP_MASK 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> btmp_bytes_len;</span><br><span class="line">    <span class="keyword">uint8_t</span>* bits;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_init</span><span class="params">(struct bitmap* btmap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitmap_scan_test</span><span class="params">(struct bitmap* btmap, <span class="keyword">uint32_t</span> bit_idx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitmap_scan</span><span class="params">(struct bitmap* btmap, <span class="keyword">uint32_t</span> cnt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_set</span><span class="params">(struct bitmap* btmap, <span class="keyword">uint32_t</span> index, <span class="keyword">int8_t</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>bitmap.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"bitmap.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"kernel/print.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"interrupt.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"debug.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_init</span><span class="params">(struct bitmap* btmap)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(btmap-&gt;bits, <span class="number">0</span>, btmap-&gt;btmp_bytes_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测指定位是否为1,如果是,返回1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitmap_scan_test</span><span class="params">(struct bitmap* btmap, <span class="keyword">uint32_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> byte_index = (index / <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> bit_odd = byte_index % <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (btmap-&gt;bits[byte_index] &amp; BITMAP_MASK &lt;&lt; bit_odd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在位图中申请连续的cnt个位.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitmap_scan</span><span class="params">(struct bitmap* btmap, <span class="keyword">uint32_t</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> idx_byte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以字节为单位进行查找</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">0xff</span> == btmap-&gt;bits[idx_byte]) &amp;&amp; idx_byte &lt; btmap-&gt;btmp_bytes_len) &#123;</span><br><span class="line">        ++idx_byte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到</span></span><br><span class="line">    <span class="keyword">if</span> (idx_byte == btmap-&gt;btmp_bytes_len) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到了一个字节不全为1,那么在字节内部再次进行查找具体的起使位</span></span><br><span class="line">    <span class="keyword">int</span> idx_bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">uint8_t</span>) BITMAP_MASK &lt;&lt; idx_bit &amp; btmap-&gt;bits[idx_byte]) &#123;</span><br><span class="line">        ++idx_bit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 起始位</span></span><br><span class="line">    <span class="keyword">int</span> bit_idx_start = (idx_byte * <span class="number">8</span> + idx_bit);</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> bit_left = (btmap-&gt;btmp_bytes_len * <span class="number">8</span> - bit_idx_start);</span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">1</span>;s</span><br><span class="line">    <span class="keyword">uint32_t</span> next_bit = bit_idx_start + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    bit_idx_start = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (bit_left-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(bitmap_scan_test(btmap, next_bit))) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == cnt) &#123;</span><br><span class="line">            bit_idx_start = (next_bit - cnt + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next_bit++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_set</span><span class="params">(struct bitmap* btmap, <span class="keyword">uint32_t</span> index, <span class="keyword">int8_t</span> value)</span> </span>&#123;</span><br><span class="line">    ASSERT(value == <span class="number">0</span> || value == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> byte_index = index / <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> bit_odd = index % <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        btmap-&gt;bits[byte_index] |= (BITMAP_MASK &lt;&lt; bit_odd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        btmap-&gt;bits[byte_index] &amp;= ~(BITMAP_MASK &lt;&lt; bit_odd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存池规划"><a href="#内存池规划" class="headerlink" title="内存池规划"></a>内存池规划</h3><p>根据之前的铺垫，为了实现内存中用户和内核的区分，我们用位图实现对内存使用情况的记录，我们将物理内存划分为用户内存池和内核内存池，一页为4KB大小。</p>
<p>内核在申请空间的时候，先从内核自己的虚拟地址池中分配好虚拟地址再从内核物理地址池中分配物理内存，最后在内核自己的页表中将这两种地址建立好映射关系，内存就分配完成。</p>
<p>对用户进程来说，它向操作系统申请内存时，操作系统先从用户进程自己的虚拟地址分配虚拟地址，在从用户物理内存池中分配空闲的物理内存，用户物理内存池是被所有用户进程所共享的。最后在用户进程自己的页表中将这两种地址建立好映射关系。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13223102339/0" alt="image-20210225111603847"></p>
<p>实现在kernel目录下新建<code>memory.c</code>和<code>memory.h</code>，虚拟内存池结构和物理内存池结构如下，物理内存多了一个记录大小的pool_size，因为虚拟地址是连续的4GB空间，相对而言空间非常大，而物理地址是有限的，所以不存在对虚拟地址大小的记录。</p>
<p><code>memory.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __KERNEL_MEMORY_H </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_MEMORY_H </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bitmap.h"</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 虚拟地址池，用于虚拟地址管理 */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> &#123;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">vaddr_bitmap</span>;</span> <span class="comment">// 虚拟地址用到的位图结构</span></span><br><span class="line">	<span class="keyword">uint32_t</span> vaddr_start; <span class="comment">// 虚拟地址起始地址</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>memory.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"memory.h"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_SIZE 4096 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************ 位图地址 ***************************** </span></span><br><span class="line"><span class="comment">* 因为 0xc009f000 是内核主线程栈顶，0xc009e000 是内核主线程的 pcb。</span></span><br><span class="line"><span class="comment">* 一个页框大小的位图可表示 128MB 内存，位图位置安排在地址 0xc009a000，</span></span><br><span class="line"><span class="comment">* 这样本系统最大支持 4 个页框的位图，即 512MB */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_BITMAP_BASE 0xc009a000 </span></span><br><span class="line"><span class="comment">/******************************************************************/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0xc0000000 是内核从虚拟地址 3G 起。</span></span><br><span class="line"><span class="comment">   0x100000 意指跨过低端 1MB 内存，使虚拟地址在逻辑上连续 */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K_HEAP_START 0xc0100000 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存池结构，生成两个实例用于管理内核内存池和用户内存池 */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> &#123;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span> <span class="comment">//本内存池用到的位图结构，用于管理物理内存</span></span><br><span class="line">	<span class="keyword">uint32_t</span> phy_addr_start; <span class="comment">// 本内存池所管理物理内存的起始地址</span></span><br><span class="line">	<span class="keyword">uint32_t</span> pool_size; <span class="comment">// 本内存池字节容量</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span> <span class="comment">// 生成内核内存池和用户内存池</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">kernel_vaddr</span>;</span> <span class="comment">// 此结构用来给内核分配虚拟地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化内存池 */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mem_pool_init</span><span class="params">(<span class="keyword">uint32_t</span> all_mem)</span> </span>&#123; </span><br><span class="line">    put_str(<span class="string">" mem_pool_init start\n"</span>); </span><br><span class="line">    <span class="keyword">uint32_t</span> page_table_size = PG_SIZE * <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页表大小 = 1 页的页目录表 + 第 0 和第 768 个页目录项指向同一个页表 + </span></span><br><span class="line">    <span class="comment">// 第 769～1022 个页目录项共指向 254 个页表，共 256 个页框</span></span><br><span class="line">    <span class="keyword">uint32_t</span> used_mem = page_table_size + <span class="number">0x100000</span>; </span><br><span class="line">    <span class="comment">// 0x100000 为低端 1MB 内存</span></span><br><span class="line">    <span class="keyword">uint32_t</span> free_mem = all_mem - used_mem; </span><br><span class="line">    <span class="keyword">uint16_t</span> all_free_pages = free_mem / PG_SIZE; </span><br><span class="line">    <span class="comment">// 1 页为 4KB，不管总内存是不是 4k 的倍数</span></span><br><span class="line">    <span class="comment">// 对于以页为单位的内存分配策略，不足 1 页的内存不用考虑了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> kernel_free_pages = all_free_pages / <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">uint16_t</span> user_free_pages = all_free_pages - kernel_free_pages; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为简化位图操作，余数不处理，坏处是这样做会丢内存。</span></span><br><span class="line"><span class="comment">    好处是不用做内存的越界检查，因为位图表示的内存少于实际物理内存*/</span> </span><br><span class="line">    <span class="keyword">uint32_t</span> kbm_length = kernel_free_pages / <span class="number">8</span>; </span><br><span class="line">    <span class="comment">// Kernel BitMap 的长度，位图中的一位表示一页，以字节为单位</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ubm_length = user_free_pages / <span class="number">8</span>; </span><br><span class="line">    <span class="comment">// User BitMap 的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> kp_start = used_mem; </span><br><span class="line">    <span class="comment">// Kernel Pool start，内核内存池的起始地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> up_start = kp_start + kernel_free_pages * PG_SIZE; </span><br><span class="line">    <span class="comment">// User Pool start，用户内存池的起始地址</span></span><br><span class="line"></span><br><span class="line">    kernel_pool.phy_addr_start = kp_start; </span><br><span class="line">    user_pool.phy_addr_start = up_start; </span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_size = kernel_free_pages * PG_SIZE; </span><br><span class="line">    user_pool.pool_size = user_free_pages * PG_SIZE; </span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length; </span><br><span class="line">    user_pool.pool_bitmap.btmp_bytes_len = ubm_length; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/********* 内核内存池和用户内存池位图 *********** </span></span><br><span class="line"><span class="comment">    * 位图是全局的数据，长度不固定。</span></span><br><span class="line"><span class="comment">    * 全局或静态的数组需要在编译时知道其长度，</span></span><br><span class="line"><span class="comment">    * 而我们需要根据总内存大小算出需要多少字节，</span></span><br><span class="line"><span class="comment">    * 所以改为指定一块内存来生成位图。</span></span><br><span class="line"><span class="comment">    * ************************************************/</span> </span><br><span class="line">    <span class="comment">// 内核使用的最高地址是 0xc009f000，这是主线程的栈地址</span></span><br><span class="line">    <span class="comment">//（内核的大小预计为 70KB 左右）</span></span><br><span class="line">    <span class="comment">// 32MB 内存占用的位图是 2KB </span></span><br><span class="line">    <span class="comment">//内核内存池的位图先定在 MEM_BITMAP_BASE(0xc009a000)处</span></span><br><span class="line">    kernel_pool.pool_bitmap.bits = (<span class="keyword">void</span>*)MEM_BITMAP_BASE; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用户内存池的位图紧跟在内核内存池位图之后 */</span> </span><br><span class="line">    user_pool.pool_bitmap.bits = (<span class="keyword">void</span>*)(MEM_BITMAP_BASE + kbm_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********************输出内存池信息**********************/</span> </span><br><span class="line">    put_str(<span class="string">" kernel_pool_bitmap_start:"</span>); </span><br><span class="line">    put_int((<span class="keyword">int</span>)kernel_pool.pool_bitmap.bits); </span><br><span class="line">    put_str(<span class="string">" kernel_pool_phy_addr_start:"</span>); </span><br><span class="line">    put_int(kernel_pool.phy_addr_start); </span><br><span class="line">    put_str(<span class="string">"\n"</span>); </span><br><span class="line">    put_str(<span class="string">"user_pool_bitmap_start:"</span>); </span><br><span class="line">    put_int((<span class="keyword">int</span>)user_pool.pool_bitmap.bits); </span><br><span class="line">    put_str(<span class="string">" user_pool_phy_addr_start:"</span>); </span><br><span class="line">    put_int(user_pool.phy_addr_start); </span><br><span class="line">    put_str(<span class="string">"\n"</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将位图置 0*/</span> </span><br><span class="line">    bitmap_init(&amp;kernel_pool.pool_bitmap); </span><br><span class="line">    bitmap_init(&amp;user_pool.pool_bitmap); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下面初始化内核虚拟地址的位图，按实际物理内存大小生成数组。*/</span> </span><br><span class="line">    kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length; </span><br><span class="line">    <span class="comment">// 用于维护内核堆的虚拟地址，所以要和内核内存池大小一致</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 位图的数组指向一块未使用的内存，</span></span><br><span class="line"><span class="comment">    目前定位在内核内存池和用户内存池之外*/</span> </span><br><span class="line">    kernel_vaddr.vaddr_bitmap.bits = (<span class="keyword">void</span>*)(MEM_BITMAP_BASE + kbm_length + ubm_length); </span><br><span class="line"></span><br><span class="line">    kernel_vaddr.vaddr_start = K_HEAP_START; </span><br><span class="line">    bitmap_init(&amp;kernel_vaddr.vaddr_bitmap); </span><br><span class="line">    put_str(<span class="string">" mem_pool_init done\n"</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存管理部分初始化入口 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	put_str(<span class="string">"mem_init start\n"</span>); </span><br><span class="line">	<span class="keyword">uint32_t</span> mem_bytes_total = (*(<span class="keyword">uint32_t</span>*)(<span class="number">0xb00</span>)); </span><br><span class="line">	mem_pool_init(mem_bytes_total); <span class="comment">// 初始化内存池</span></span><br><span class="line">	put_str(<span class="string">"mem_init done\n"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面创建页目录和页表的时候，我们将虚拟地址 <code>0xc0000000~0xc00fffff</code> 映射到了物理地址 <code>0x0~0xfffff</code>，0xc0000000 是内核空间的起始虚拟地址，这 1MB 空间做的对等映射。为了看起来使内存连续，所以这里内核堆空间的开始地址从 0xc0100000 开始，在之前的设计中，0xc009f000 为内核主线程的栈顶，0xc009e000 将作为主线程的 PCB 使用，那么在低端1MB的空间中，就只剩下<code>0xc009a000~0xc009dfff</code>这<code>4 * 4KB</code>的空间未使用，所以位图的地址就安排在 0xc009a000 处，这里还剩下四个页框的大小，所能表示的内存大小为512MB。</p>
<p><code>init.c</code> 需要添加 <code>mem_init()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"init.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"timer.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"memory.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    put_str(<span class="string">"init_all.\n"</span>);</span><br><span class="line">    idt_init();</span><br><span class="line">    timer_init();</span><br><span class="line">    mem_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>global.h</code> 需要加个 NULL 的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _KERNEL_GLOBAL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _KERNEL_GLOBAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> RPL0 0</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> RPL1 1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> RPL2 2</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> RPL3 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TI_GDT 0</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TI_LDT 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SELECTOR_K_CODE ((1 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SELECTOR_K_DATA ((2 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SELECTOR_K_STACK SELECTOR_K_DATA</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SELECTOR_K_GS ((3 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IDT描述符属性 */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> IDT_DESC_P 1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> IDT_DESC_DPL0 0</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> IDT_DESC_DPL3 3</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> IDT_DESC_32_TYPE 0xE   <span class="comment">// 32 位的门</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> IDT_DESC_16_TYPE 0x6   <span class="comment">// 16 位的门</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> IDT_DESC_ATTR_DPL0 \</span></span><br><span class="line">    ((IDT_DESC_P &lt;&lt; <span class="number">7</span>) + (IDT_DESC_DPL0 &lt;&lt; <span class="number">5</span>) + IDT_DESC_32_TYPE)</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> IDT_DESC_ATTR_DPL3 \</span></span><br><span class="line">    ((IDT_DESC_P &lt;&lt; <span class="number">7</span>) + (IDT_DESC_DPL3 &lt;&lt; <span class="number">5</span>) + IDT_DESC_32_TYPE)</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>main.c</code> 测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"init.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"debug.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"memory.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    put_str(<span class="string">"I am kernel.\n"</span>);</span><br><span class="line">    init_all();</span><br><span class="line">    put_str(<span class="string">"Init done.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要修改 <code>makefile</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">BUILD_DIR &#x3D; .&#x2F;build</span><br><span class="line">ENTRY_POINT &#x3D; 0xc0001500</span><br><span class="line">AS &#x3D; nasm</span><br><span class="line">CC &#x3D; gcc</span><br><span class="line">LD &#x3D; ld</span><br><span class="line">LIB &#x3D; -I lib&#x2F; -I lib&#x2F;kernel&#x2F; -I lib&#x2F;user&#x2F; -I kernel&#x2F; -I device&#x2F;</span><br><span class="line">ASFLAGS &#x3D; -f elf</span><br><span class="line">CFLAGS &#x3D; -m32 -fno-stack-protector -Wall $(LIB) -c -fno-builtin -W -Wstrict-prototypes \</span><br><span class="line">         -Wmissing-prototypes</span><br><span class="line">LDFLAGS &#x3D; -m elf_i386 -Ttext $(ENTRY_POINT) -e main -Map $(BUILD_DIR)&#x2F;kernel.map</span><br><span class="line">OBJS &#x3D; $(BUILD_DIR)&#x2F;main.o $(BUILD_DIR)&#x2F;init.o $(BUILD_DIR)&#x2F;interrupt.o \</span><br><span class="line">      $(BUILD_DIR)&#x2F;timer.o $(BUILD_DIR)&#x2F;kernel.o $(BUILD_DIR)&#x2F;print.o \</span><br><span class="line">      $(BUILD_DIR)&#x2F;debug.o $(BUILD_DIR)&#x2F;bitmap.o $(BUILD_DIR)&#x2F;memory.o \</span><br><span class="line">      $(BUILD_DIR)&#x2F;string.o</span><br><span class="line"></span><br><span class="line">##############     c代码编译     ###############</span><br><span class="line">$(BUILD_DIR)&#x2F;main.o: kernel&#x2F;main.c lib&#x2F;kernel&#x2F;print.h \</span><br><span class="line">        lib&#x2F;stdint.h kernel&#x2F;init.h kernel&#x2F;memory.h kernel&#x2F;debug.h</span><br><span class="line">        $(CC) $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)&#x2F;init.o: kernel&#x2F;init.c kernel&#x2F;init.h lib&#x2F;kernel&#x2F;print.h \</span><br><span class="line">        lib&#x2F;stdint.h kernel&#x2F;interrupt.h device&#x2F;timer.h kernel&#x2F;memory.h</span><br><span class="line">        $(CC) $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)&#x2F;interrupt.o: kernel&#x2F;interrupt.c kernel&#x2F;interrupt.h \</span><br><span class="line">        lib&#x2F;stdint.h kernel&#x2F;global.h lib&#x2F;kernel&#x2F;io.h lib&#x2F;kernel&#x2F;print.h</span><br><span class="line">        $(CC) $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)&#x2F;timer.o: device&#x2F;timer.c device&#x2F;timer.h lib&#x2F;stdint.h\</span><br><span class="line">        lib&#x2F;kernel&#x2F;io.h lib&#x2F;kernel&#x2F;print.h</span><br><span class="line">        $(CC) $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)&#x2F;debug.o: kernel&#x2F;debug.c kernel&#x2F;debug.h \</span><br><span class="line">        lib&#x2F;kernel&#x2F;print.h lib&#x2F;stdint.h kernel&#x2F;interrupt.h</span><br><span class="line">        $(CC) $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)&#x2F;string.o: lib&#x2F;string.c lib&#x2F;string.h \</span><br><span class="line">        kernel&#x2F;global.h kernel&#x2F;debug.h</span><br><span class="line">        $(CC) $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)&#x2F;bitmap.o: lib&#x2F;bitmap.c lib&#x2F;bitmap.h \</span><br><span class="line">        kernel&#x2F;debug.h kernel&#x2F;interrupt.h lib&#x2F;stdint.h</span><br><span class="line">        $(CC) $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(BUILD_DIR)&#x2F;memory.o: kernel&#x2F;memory.c kernel&#x2F;memory.h lib&#x2F;bitmap.h \</span><br><span class="line">        lib&#x2F;stdint.h lib&#x2F;kernel&#x2F;print.h kernel&#x2F;debug.h lib&#x2F;string.h</span><br><span class="line">        $(CC) $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##############    汇编代码编译    ###############</span><br><span class="line">$(BUILD_DIR)&#x2F;kernel.o: kernel&#x2F;kernel.S</span><br><span class="line">        $(AS) $(ASFLAGS) $&lt; -o $@</span><br><span class="line">$(BUILD_DIR)&#x2F;print.o: lib&#x2F;kernel&#x2F;print.S</span><br><span class="line">        $(AS) $(ASFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">##############    链接所有目标文件    #############</span><br><span class="line">$(BUILD_DIR)&#x2F;kernel.bin: $(OBJS)</span><br><span class="line">        $(LD) $(LDFLAGS) $^ -o $@</span><br><span class="line"></span><br><span class="line">.PHONY : mk_dir hd clean all</span><br><span class="line"></span><br><span class="line"># ubantu中需要将dash修改为bash运行</span><br><span class="line"># ls -al &#x2F;bin&#x2F;sh若结果为&#x2F;bin&#x2F;sh -&gt; dash</span><br><span class="line"># 执行sudo dpkg-reconfigure dash选择No即可</span><br><span class="line">mk_dir:</span><br><span class="line">        if [[ ! -d $(BUILD_DIR) ]];then mkdir $(BUILD_DIR);fi</span><br><span class="line"></span><br><span class="line">hd:</span><br><span class="line">        dd if&#x3D;$(BUILD_DIR)&#x2F;kernel.bin \</span><br><span class="line">           of&#x3D;&#x2F;home&#x2F;fyz&#x2F;sc&#x2F;bochs-2.6.2&#x2F;hd60M.img \</span><br><span class="line">           bs&#x3D;512 count&#x3D;200 seek&#x3D;9 conv&#x3D;notrunc</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        cd $(BUILD_DIR) &amp;&amp; rm -f .&#x2F;*</span><br><span class="line"></span><br><span class="line">build: $(BUILD_DIR)&#x2F;kernel.bin</span><br><span class="line"></span><br><span class="line">all: mk_dir build hd</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--sudo make all</span><br><span class="line">--sudo bin&#x2F;bochs -f bochsrc.disk</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13223102369/0" alt="image-20210225143014643"> </p>
<h3 id="分配页内存"><a href="#分配页内存" class="headerlink" title="分配页内存"></a>分配页内存</h3><p>接下来就是实现对内存的分配，首先复习一下32位虚拟地址的转换过程：</p>
<ol>
<li>高 10 位是页目录项 pde 的索引，用于在页目录表中定位 pde ，细节是处理器获取高 10 位后自动将其乘以 4，再加上页目录表的物理地址，这样便得到了 pde 索引对应的 pde 所在的物理地址，然后自动在该物理地址中，即该 pde 中，获取保存的页表物理地址。</li>
<li>中间 10 位是页表项 pte 索引，用于在页表中定位 pte 。细节是处理器获取中间 10 位后自动将其乘以 4，再加上第一步中得到的页表的物理地址，这样便得到了 pte 索引对应的 pte 所在的物理地址，然后自动在该物理地址 (该 pte) 中获取保存的普通物理页的物理地址。</li>
<li>低 12 位是物理页内的偏移 ，页大小是 4KB, 12 位可寻址的范围正好是 4KB，因此处理器便直接把低 12 位作为第二步中获取的物理页的偏移量，无需乘以 4。用物理页的物理地址加上这低 12 位的和便是这 32 位虚拟地址最终落向的物理地址。</li>
</ol>
<p>比如访问虚拟地址<code>0x00c03123</code>，拆分步骤如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x00c03123 &#x3D;&gt; 16进制</span><br><span class="line">0000 0000 1100 0000 0011 0001 0010 0011 &#x3D;&gt; 2进制</span><br><span class="line">0000000011 0000000011 000100100011      &#x3D;&gt; 重新组合为 10+10+12</span><br><span class="line">pde 3      pte 3      偏移 123</span><br></pre></td></tr></table></figure>

<p>整个过程如下图所示</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13223102424/0" alt="image-20210225144142146"> </p>
<p>32位地址在上面转换之后则落向物理地址，内存分配的过程：</p>
<ol>
<li>在虚拟内存池中申请n个虚拟页</li>
<li>在物理内存池中分配物理页</li>
<li>在页表中添加虚拟地址与物理地址的映射关系</li>
</ol>
<p>接下来就是一步一步在<code>memory</code>文件中增加函数</p>
<p><strong>在虚拟内存池中申请n个虚拟页</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页,</span></span><br><span class="line"><span class="comment"> * 成功则返回虚拟页的起始地址, 失败则返回NULL */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">vaddr_get</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">uint32_t</span> pg_cnt)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> vaddr_start = <span class="number">0</span>, bit_idx_start = <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (pf == PF_KERNEL) &#123; <span class="comment">//若为内核内存池</span></span><br><span class="line">       bit_idx_start  = bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap, pg_cnt); <span class="comment">// 扫描虚拟地址池</span></span><br><span class="line">       <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>) &#123; <span class="comment">// 返回-1则退出</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(cnt &lt; pg_cnt) &#123;</span><br><span class="line">		  bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">1</span>); <span class="comment">// 循环逐位置一</span></span><br><span class="line">      &#125;</span><br><span class="line">      vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE; <span class="comment">// 将bit_idx_start转换为虚拟地址</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;	</span><br><span class="line">   <span class="comment">// 用户内存池,将来实现用户进程再补充</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">void</span>*)vaddr_start; <span class="comment">// 返回指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在物理内存池中分配物理页</strong></p>
<p>这个函数比较关键，主要是对位图的扫描和记录，然后根据位图索引返回分配的物理地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在m_pool指向的物理内存池中分配一个物理页</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">palloc</span><span class="params">(struct pool *m_pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bit_idx = bitmap_scan(&amp;m_pool-&gt;pool_bitmap, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(bit_idx == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bitmap_set(&amp;m_pool-&gt;pool_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> page_phyaddr = bit_idx * PG_SIZE + m_pool-&gt;phy_addr_start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)page_phyaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在页表中添加虚拟地址与物理地址的映射关系</strong></p>
<p>再次复习一下32位虚拟地址到物理地址的转换，我们后面实现pde和pte访问就是用的这个原理</p>
<ol>
<li>首先通过高10位的pde索引，找到页表的物理地址</li>
<li>其次通过中间10位的pte索引，得到物理页的物理地址</li>
<li>最后把低12位作为物理页的页内偏移，加上物理页的物理地址，即为最终的物理地址</li>
</ol>
<p>下面是通过虚拟地址访问pte和pde的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 得到虚拟地址vaddr对应的pte指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span>* <span class="title">pte_ptr</span><span class="params">(<span class="keyword">uint32_t</span> vaddr)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 先访问到页表自己 + \</span></span><br><span class="line"><span class="comment">    * 再用页目录项pde(页目录内页表的索引)做为pte的索引访问到页表 + \</span></span><br><span class="line"><span class="comment">    * 再用pte的索引做为页内偏移*/</span></span><br><span class="line">   	<span class="keyword">uint32_t</span>* pte = (<span class="keyword">uint32_t</span>*)(<span class="number">0xffc00000</span> + \ <span class="comment">// 最后一个页目录项保存的是页目录表物理地址，高十位指向最后一个页目录表项</span></span><br><span class="line">                                              <span class="comment">// 也就是第1023个pde，换算成十进制就是0x3ff再移到高10位就是0xffc00000</span></span><br><span class="line">	 ((vaddr &amp; <span class="number">0xffc00000</span>) &gt;&gt; <span class="number">10</span>) + \        </span><br><span class="line">	 PTE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> pte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 得到虚拟地址vaddr对应的pde的指针 */</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span>* <span class="title">pde_ptr</span><span class="params">(<span class="keyword">uint32_t</span> vaddr)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 0xfffff是用来访问到页表本身所在的地址 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* pde = (<span class="keyword">uint32_t</span>*)((<span class="number">0xfffff000</span>) + PDE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> pde;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>m_pool</code>处申请物理页的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在m_pool指向的物理内存池中分配1个物理页,</span></span><br><span class="line"><span class="comment"> * 成功则返回页框的物理地址,失败则返回NULL */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">palloc</span><span class="params">(struct pool* m_pool)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 扫描或设置位图要保证原子操作 */</span></span><br><span class="line">   <span class="keyword">int</span> bit_idx = bitmap_scan(&amp;m_pool-&gt;pool_bitmap, <span class="number">1</span>);    <span class="comment">// 找一个物理页面</span></span><br><span class="line">   <span class="keyword">if</span> (bit_idx == <span class="number">-1</span> ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   bitmap_set(&amp;m_pool-&gt;pool_bitmap, bit_idx, <span class="number">1</span>);	<span class="comment">// 将此位bit_idx置1</span></span><br><span class="line">   <span class="keyword">uint32_t</span> page_phyaddr = ((bit_idx * PG_SIZE) + m_pool-&gt;phy_addr_start); <span class="comment">// page_phyaddr用于保存分配的物理页地址</span></span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">void</span>*)page_phyaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加虚拟地址与物理地址的映射函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">page_table_add</span><span class="params">(<span class="keyword">void</span>* _vaddr, <span class="keyword">void</span>* _page_phyaddr)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> vaddr = (<span class="keyword">uint32_t</span>)_vaddr, page_phyaddr = (<span class="keyword">uint32_t</span>)_page_phyaddr;</span><br><span class="line">   <span class="keyword">uint32_t</span>* pde = pde_ptr(vaddr);</span><br><span class="line">   <span class="keyword">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************   注意   *************************</span></span><br><span class="line"><span class="comment"> * 执行*pte,会访问到空的pde。所以确保pde创建完成后才能执行*pte,</span></span><br><span class="line"><span class="comment"> * 否则会引发page_fault。因此在*pde为0时,*pte只能出现在下面else语句块中的*pde后面。</span></span><br><span class="line"><span class="comment"> * *********************************************************/</span></span><br><span class="line">   <span class="comment">/* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */</span></span><br><span class="line">   <span class="keyword">if</span> (*pde &amp; <span class="number">0x00000001</span>) &#123;	 <span class="comment">// 页目录项和页表项的第0位为P,此处判断目录项是否存在</span></span><br><span class="line">      ASSERT(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(*pte &amp; <span class="number">0x00000001</span>)) &#123;   <span class="comment">// 只要是创建页表,pte就应该不存在,多判断一下放心</span></span><br><span class="line">		 *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);    <span class="comment">// US=1,RW=1,P=1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;			    <span class="comment">//应该不会执行到这，因为上面的ASSERT会先执行。</span></span><br><span class="line">	 	 PANIC(<span class="string">"pte repeat"</span>);</span><br><span class="line">	 	 *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);      <span class="comment">// US=1,RW=1,P=1</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;			    <span class="comment">// 页目录项不存在,所以要先创建页目录再创建页表项.</span></span><br><span class="line">      <span class="comment">/* 页表中用到的页框一律从内核空间分配 */</span></span><br><span class="line">      <span class="keyword">uint32_t</span> pde_phyaddr = (<span class="keyword">uint32_t</span>)palloc(&amp;kernel_pool);</span><br><span class="line"></span><br><span class="line">      *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 分配到的物理页地址pde_phyaddr对应的物理内存清0,</span></span><br><span class="line"><span class="comment">       * 避免里面的陈旧数据变成了页表项,从而让页表混乱.</span></span><br><span class="line"><span class="comment">       * 访问到pde对应的物理地址,用pte取高20位便可.</span></span><br><span class="line"><span class="comment">       * 因为pte是基于该pde对应的物理地址内再寻址,</span></span><br><span class="line"><span class="comment">       * 把低12位置0便是该pde对应的物理页的起始*/</span></span><br><span class="line">      <span class="built_in">memset</span>((<span class="keyword">void</span>*)((<span class="keyword">int</span>)pte &amp; <span class="number">0xfffff000</span>), <span class="number">0</span>, PG_SIZE);</span><br><span class="line">         </span><br><span class="line">      ASSERT(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line">      *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);      <span class="comment">// US=1,RW=1,P=1</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>malloc_page</code>函数负责申请虚拟地址并分配物理地址、建立映射，大致步骤如下</p>
<ol>
<li>通过vaddr_get在虚拟内存池中申请虚拟地址</li>
<li>通过palloc在物理内存池中申请物理页</li>
<li>通过page_table_add将以上两步得到的结果在页表中映射</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分配pg_cnt个页空间,成功则返回起始虚拟地址,失败时返回NULL */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">uint32_t</span> pg_cnt)</span> </span>&#123;</span><br><span class="line">	ASSERT(pg_cnt &gt; <span class="number">0</span> &amp;&amp; pg_cnt &lt; <span class="number">3840</span>); <span class="comment">//15MB来限制，pg_cnt &lt; 15*1024*1024/4096 = 3840页</span></span><br><span class="line"><span class="comment">/***********   malloc_page的原理是三个动作的合成:   ***********</span></span><br><span class="line"><span class="comment">      1通过vaddr_get在虚拟内存池中申请虚拟地址</span></span><br><span class="line"><span class="comment">      2通过palloc在物理内存池中申请物理页</span></span><br><span class="line"><span class="comment">      3通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line">    <span class="keyword">void</span>* vaddr_start = vaddr_get(pf, pg_cnt);</span><br><span class="line">    <span class="keyword">if</span> (vaddr_start == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> vaddr = (<span class="keyword">uint32_t</span>)vaddr_start, cnt = pg_cnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span> = <span class="title">pf</span> &amp; <span class="title">PF_KERNEL</span> ? &amp;<span class="title">kernel_pool</span> :</span> &amp;user_pool; <span class="comment">// 内核池还是用户池</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/</span></span><br><span class="line">    <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span>* page_phyaddr = palloc(mem_pool);</span><br><span class="line">        <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>) &#123;  <span class="comment">// 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        page_table_add((<span class="keyword">void</span>*)vaddr, page_phyaddr); <span class="comment">// 在页表中做映射 </span></span><br><span class="line">        vaddr += PG_SIZE;		 <span class="comment">// 下一个虚拟页</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vaddr_start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个函数负责在物理内存池中申请 pg_cnt 页内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_kernel_pages</span><span class="params">(<span class="keyword">uint32_t</span> pg_cnt)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">void</span>* vaddr =  malloc_page(PF_KERNEL, pg_cnt);</span><br><span class="line">   <span class="keyword">if</span> (vaddr != <span class="literal">NULL</span>) &#123;	   <span class="comment">// 若分配的地址不为空,将页框清0后返回</span></span><br><span class="line">      <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, pg_cnt * PG_SIZE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>memery.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> _KERNEL_MEMORY_H</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _KERNEL_MEMORY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"bitmap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在标志</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PG_P_1 1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PG_P_0 0</span></span><br><span class="line"><span class="comment">// 只读</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PG_RW_R 0</span></span><br><span class="line"><span class="comment">// 可写</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PG_RW_W 2</span></span><br><span class="line"><span class="comment">// 系统级</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PG_US_S 0</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PG_US_U 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存池类型标志.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">enum</span> pool_flags &#123;</span><br><span class="line">    <span class="comment">// 内核类型</span></span><br><span class="line">    PF_KERNEL = <span class="number">1</span>,</span><br><span class="line">    PF_USER = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">vaddr_bitmap</span>;</span></span><br><span class="line">    <span class="comment">// 虚拟内存的起始地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> vaddr_start;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_kernel_pages</span><span class="params">(<span class="keyword">uint32_t</span> page_count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">uint32_t</span> page_count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>memery.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"memory.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"kernel/print.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"debug.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位图地址</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MEM_BITMAP_BASE 0xc009a000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核使用的起始虚拟地址</span></span><br><span class="line"><span class="comment">// 跳过低端1MB内存，中间10为代表页表项偏移，即0x100，即256 * 4KB = 1MB</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> K_HEAD_START 0xc0100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取高10位页目录项标记</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PDE_INDEX(addr) ((addr &amp; 0xffc00000) &gt;&gt; 22)</span></span><br><span class="line"><span class="comment">// 获取中间10位页表标记 </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PTE_INDEX(addr) ((addr &amp; 0x003ff000) &gt;&gt; 12) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// static functions declarations</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printKernelPoolInfo</span><span class="params">(struct pool p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUserPoolInfo</span><span class="params">(struct pool p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">vaddr_get</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">uint32_t</span> pg_count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span>* <span class="title">pte_ptr</span><span class="params">(<span class="keyword">uint32_t</span> vaddr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span>* <span class="title">pde_ptr</span><span class="params">(<span class="keyword">uint32_t</span> vaddr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">palloc</span><span class="params">(struct pool* m_pool)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">page_table_add</span><span class="params">(<span class="keyword">void</span>* _vaddr, <span class="keyword">void</span>* _page_phyaddr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">pool_bitmap</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> phy_addr_start;</span><br><span class="line">    <span class="keyword">uint32_t</span> pool_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool</span> <span class="title">kernel_pool</span>, <span class="title">user_pool</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">kernel_addr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化内存池.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mem_pool_init</span><span class="params">(<span class="keyword">uint32_t</span> all_memory)</span> </span>&#123;</span><br><span class="line">    put_str(<span class="string">"Start init Memory pool...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页表(一级和二级)占用的内存大小，256的由来:</span></span><br><span class="line">    <span class="comment">// 一页的页目录，页目录的第0和第768项指向一个页表，此页表分配了低端1MB内存(其实此页表中也只是使用了256个表项)，</span></span><br><span class="line">    <span class="comment">// 剩余的254个页目录项实际没有分配对应的真实页表，但是需要为内核预留分配的空间</span></span><br><span class="line">    <span class="keyword">uint32_t</span> page_table_size = PAGE_SIZE * <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经使用的内存为: 低端1MB内存 + 现有的页表和页目录占据的空间</span></span><br><span class="line">    <span class="keyword">uint32_t</span> used_mem = (page_table_size + <span class="number">0x100000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> free_mem = (all_memory - used_mem);</span><br><span class="line">    <span class="keyword">uint16_t</span> free_pages = free_mem / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> kernel_free_pages = (free_pages &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">uint16_t</span> user_free_pages = (free_pages - kernel_free_pages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核空间bitmap长度(字节)，每一位代表一页</span></span><br><span class="line">    <span class="keyword">uint32_t</span> kernel_bitmap_length = kernel_free_pages / <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> user_bitmap_length = user_free_pages / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核内存池起始物理地址，注意内核的虚拟地址占据地址空间的顶端，但是实际映射的物理地址是在这里</span></span><br><span class="line">    <span class="keyword">uint32_t</span> kernel_pool_start = used_mem;</span><br><span class="line">    <span class="keyword">uint32_t</span> user_pool_start = (kernel_pool_start + kernel_free_pages * PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    kernel_pool.phy_addr_start = kernel_pool_start;</span><br><span class="line">    user_pool.phy_addr_start = user_pool_start;</span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_size = kernel_free_pages * PAGE_SIZE;</span><br><span class="line">    user_pool.pool_size = user_free_pages * PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_bitmap.btmp_bytes_len = kernel_bitmap_length;</span><br><span class="line">    user_pool.pool_bitmap.btmp_bytes_len = user_bitmap_length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核bitmap和user bitmap bit数组的起始地址</span></span><br><span class="line">    kernel_pool.pool_bitmap.bits = (<span class="keyword">void</span>*) MEM_BITMAP_BASE;</span><br><span class="line">    user_pool.pool_bitmap.bits = (<span class="keyword">void</span>*) (MEM_BITMAP_BASE + kernel_bitmap_length);</span><br><span class="line"></span><br><span class="line">    printKernelPoolInfo(kernel_pool);</span><br><span class="line">    printUserPoolInfo(user_pool);</span><br><span class="line"></span><br><span class="line">    bitmap_init(&amp;kernel_pool.pool_bitmap);</span><br><span class="line">    bitmap_init(&amp;user_pool.pool_bitmap);</span><br><span class="line"></span><br><span class="line">    kernel_addr.vaddr_bitmap.btmp_bytes_len = kernel_bitmap_length;</span><br><span class="line">    <span class="comment">// 内核虚拟地址池仍然保存在低端内存以内</span></span><br><span class="line">    kernel_addr.vaddr_bitmap.bits = (<span class="keyword">void</span>*) (MEM_BITMAP_BASE + kernel_bitmap_length + user_bitmap_length);</span><br><span class="line">    kernel_addr.vaddr_start = K_HEAD_START;</span><br><span class="line"></span><br><span class="line">    bitmap_init(&amp;kernel_addr.vaddr_bitmap);</span><br><span class="line">    put_str(<span class="string">"Init memory pool done.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printKernelPoolInfo</span><span class="params">(struct pool p)</span> </span>&#123;</span><br><span class="line">    put_str(<span class="string">"Kernel pool bitmap address: "</span>);</span><br><span class="line">    put_int(p.pool_bitmap.bits);</span><br><span class="line">    put_str(<span class="string">"; Kernel pool physical address: "</span>);</span><br><span class="line">    put_int(p.phy_addr_start);</span><br><span class="line">    put_char(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUserPoolInfo</span><span class="params">(struct pool p)</span> </span>&#123;</span><br><span class="line">    put_str(<span class="string">"User pool bitmap address: "</span>);</span><br><span class="line">    put_int(p.pool_bitmap.bits);</span><br><span class="line">    put_str(<span class="string">"; User pool physical address: "</span>);</span><br><span class="line">    put_int(p.phy_addr_start);</span><br><span class="line">    put_char(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 申请指定个数的虚拟页.返回虚拟页的起始地址，失败返回NULL.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">vaddr_get</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">uint32_t</span> pg_count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vaddr_start = <span class="number">0</span>, bit_idx_start = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pf == PF_KERNEL) &#123;</span><br><span class="line">        bit_idx_start = bitmap_scan(&amp;kernel_addr.vaddr_bitmap, pg_count);</span><br><span class="line">        <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 申请失败，虚拟内存不足</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改bitmap，占用虚拟内存</span></span><br><span class="line">        <span class="keyword">while</span> (count &lt; pg_count) &#123;</span><br><span class="line">            bitmap_set(&amp;kernel_addr.vaddr_bitmap, (bit_idx_start + count), <span class="number">1</span>);</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vaddr_start = (kernel_addr.vaddr_start + bit_idx_start * PAGE_SIZE); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用户内存分配暂不支持</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*) vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到虚拟地址对应的PTE的指针.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span>* <span class="title">pte_ptr</span><span class="params">(<span class="keyword">uint32_t</span> vaddr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>*) (<span class="number">0xffc00000</span> + ((vaddr &amp; <span class="number">0xffc00000</span>) &gt;&gt; <span class="number">10</span>) + (PTE_INDEX(vaddr) &lt;&lt; <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到虚拟地址对应的PDE指针.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span>* <span class="title">pde_ptr</span><span class="params">(<span class="keyword">uint32_t</span> vaddr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>*) ((<span class="number">0xfffff000</span>) + (PDE_INDEX(vaddr) &lt;&lt; <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在给定的物理内存池中分配一个物理页，返回其物理地址.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">palloc</span><span class="params">(struct pool* m_pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bit_index = bitmap_scan(&amp;m_pool-&gt;pool_bitmap, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (bit_index == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bitmap_set(&amp;m_pool-&gt;pool_bitmap, bit_index, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> page_phyaddr = ((bit_index * PAGE_SIZE) + m_pool-&gt;phy_addr_start);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*) page_phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过页表建立虚拟页与物理页的映射关系.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">page_table_add</span><span class="params">(<span class="keyword">void</span>* _vaddr, <span class="keyword">void</span>* _page_phyaddr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> vaddr = (<span class="keyword">uint32_t</span>) _vaddr, page_phyaddr = (<span class="keyword">uint32_t</span>) _page_phyaddr;</span><br><span class="line">    <span class="keyword">uint32_t</span>* pde = pde_ptr(vaddr); <span class="keyword">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; <span class="number">0x00000001</span>) &#123;</span><br><span class="line">        <span class="comment">// 页目录项已经存在</span></span><br><span class="line">        <span class="keyword">if</span> (!(*pte &amp; <span class="number">0x00000001</span>)) &#123;</span><br><span class="line">            <span class="comment">// 物理页必定不存在，使页表项指向我们新分配的物理页</span></span><br><span class="line">            *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 新分配一个物理页作为页表</span></span><br><span class="line">        <span class="keyword">uint32_t</span> pde_phyaddr = (<span class="keyword">uint32_t</span>) palloc(&amp;kernel_pool);</span><br><span class="line">        *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">        <span class="comment">// 清理物理页</span></span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span>*) ((<span class="keyword">int</span>) pte &amp; <span class="number">0xfffff000</span>), <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">        *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配page_count个页空间，自动建立虚拟页与物理页的映射.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">uint32_t</span> page_count)</span> </span>&#123;</span><br><span class="line">    ASSERT(page_count &gt; <span class="number">0</span> &amp;&amp; page_count &lt; <span class="number">3840</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在虚拟地址池中申请虚拟内存</span></span><br><span class="line">    <span class="keyword">void</span>* vaddr_start = vaddr_get(pf, page_count);</span><br><span class="line">    <span class="keyword">if</span> (vaddr_start == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> vaddr = (<span class="keyword">uint32_t</span>) vaddr_start, count = page_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span> = (<span class="title">pf</span> &amp; <span class="title">PF_KERNEL</span>) ? &amp;<span class="title">kernel_pool</span> :</span> &amp;user_pool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 物理页不必连续，逐个与虚拟页做映射</span></span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span>* page_phyaddr = palloc(mem_pool);</span><br><span class="line">        <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page_table_add((<span class="keyword">void</span>*) vaddr, page_phyaddr);</span><br><span class="line">        vaddr += PAGE_SIZE;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在内核内存池中申请page_count个页.</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_kernel_pages</span><span class="params">(<span class="keyword">uint32_t</span> page_count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* vaddr = malloc_page(PF_KERNEL, page_count);</span><br><span class="line">    <span class="keyword">if</span> (vaddr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, page_count * PAGE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    put_str(<span class="string">"Init memory start.\n"</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> total_memory = (*(<span class="keyword">uint32_t</span>*) (<span class="number">0xb00</span>));</span><br><span class="line">    mem_pool_init(total_memory);</span><br><span class="line">    put_str(<span class="string">"Init memory done.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们在main.c中添加测试代码，申请三个页并打印其虚拟地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"init.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"memory.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"Welcome to TJ's kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line">   <span class="keyword">void</span>* addr = get_kernel_pages(<span class="number">3</span>);</span><br><span class="line">   put_str(<span class="string">"\n get_kernel_page start vaddr is "</span>);</span><br><span class="line">   put_int((<span class="keyword">uint32_t</span>)addr);</span><br><span class="line">   put_str(<span class="string">"\n"</span>);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13223102470/0" alt="image-20210226101349686"> </p>

      
      <!-- reward -->
      
      <div id="reward-btn">
        Reward
      </div>
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>Copyright： </strong>
              Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://yoursite.com/2021/02/27/cx6/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/" rel="tag">操作系统真象还原</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
    
      <a href="/2021/02/21/cx2/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">操作系统真象还原&lt;第二部分&gt;</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2021
        John Doe
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['你努力，剩下的交给我', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>




<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>





<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>


    
  </div>
</body>

</html>