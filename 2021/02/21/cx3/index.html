<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    操作系统真象还原&lt;第三部分&gt; |  Hexo
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      <section class="outer">
  <article id="post-cx3" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  操作系统真象还原&lt;第三部分&gt;
</h1>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/02/21/cx3/" class="article-date">
  <time datetime="2021-02-20T16:00:00.000Z" itemprop="datePublished">2021-02-21</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">15.2k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">61 min</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>(｡･∀･)ﾉﾞ嗨起来！！！</p>
<a id="more"></a>

<h1 id="向内核迈进"><a href="#向内核迈进" class="headerlink" title="向内核迈进"></a>向内核迈进</h1><h2 id="获取物理内存容量"><a href="#获取物理内存容量" class="headerlink" title="获取物理内存容量"></a>获取物理内存容量</h2><p>inux获取内存容量方法有三种，本质上分别是BIOS中断0x15的3个子功能，BIOS是实模式下的方法，只能在保护模式之前调用。</p>
<p><strong>利用BIOS中断0x15子功能0xe820获取内存</strong></p>
<p>此方法最灵活，返回的内容也最丰富，内存信息的内容是地址范围描述符来描述的(ARDS)，每个字段4字节，一共20字节，调用0x15返回的也就是这个结构。其中Type字段表示内存类型，1表示这段内存可以使用；2表示不可用使用此内存；其它表示未定义，将来会用到。</p>
<p> <img src="https://inews.gtimg.com/newsapp_ls/0/13190601325/0" alt="image-20201022190231494"></p>
<p>用0x15子功能0xe820调用说明和调用步骤如下</p>
<ol>
<li><p>填写好”调用前输入”中列出的寄存器</p>
</li>
<li><p>执行中断调用 int 0x15</p>
</li>
<li><p>在CF位为0的情况下，”返回后输出”中对应的寄存器中就有结果</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601345/0" alt="image-20201022190424025"></p>
</li>
</ol>
<p><strong>利用BIOS中断0x15子功能0xe801获取内存</strong></p>
<p>此方法最多识别4G的内存，结果存放在两组寄存器中，操作起来要简便一些，调用说明和调用步骤如下</p>
<ol>
<li>AX寄存器写入0xE801</li>
<li>执行中断调用 int 0x15</li>
<li>在CF位为0的情况下，”返回后输出”中对应的寄存器中就有结果</li>
</ol>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601379/0" alt="image-20201022190558027"></p>
<p><strong>利用BIOS中断0x15子功能0x88获取内存</strong></p>
<p>此方法最多识别64MB内存，操作起来最简单，调用说明和调用步骤如下</p>
<ol>
<li>AX寄存器写入0x88</li>
<li>执行中断调用 int 0x15</li>
<li>在CF位为0的情况下，”返回后输出”中对应的寄存器中就有结果</li>
</ol>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601408/0" alt="image-20201022190849105"></p>
<p>下面结合这三种方式改进我们的实验代码，下面是<code>loader</code>，我们将结果保存在了<code>total_mem_bytes</code>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">   %include &quot;boot.inc&quot;</span><br><span class="line">   section loader vstart&#x3D;LOADER_BASE_ADDR</span><br><span class="line">   LOADER_STACK_TOP equ LOADER_BASE_ADDR</span><br><span class="line">   </span><br><span class="line">;构建gdt及其内部的描述符</span><br><span class="line">   GDT_BASE:   dd    0x00000000 </span><br><span class="line">	          dd    0x00000000</span><br><span class="line"></span><br><span class="line">   CODE_DESC:  dd    0x0000FFFF </span><br><span class="line">	          dd    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line">   DATA_STACK_DESC:  dd    0x0000FFFF</span><br><span class="line">	                dd    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line">   VIDEO_DESC:  dd    0x80000007	   ; limit&#x3D;(0xbffff-0xb8000)&#x2F;4k&#x3D;0x7</span><br><span class="line">	           dd    DESC_VIDEO_HIGH4  ; 此时dpl为0</span><br><span class="line"> </span><br><span class="line">   GDT_SIZE   equ   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   equ   GDT_SIZE -	1 </span><br><span class="line">   times 60 dq 0					 ; 此处预留60个描述符的空位(slot)</span><br><span class="line">   SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0     ; 相当于(CODE_DESC - GDT_BASE)&#x2F;8 + TI_GDT + RPL0</span><br><span class="line">   SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0	 ; 同上</span><br><span class="line">   SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0	 ; 同上 </span><br><span class="line"></span><br><span class="line">   ; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。</span><br><span class="line">   ; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,</span><br><span class="line">   ; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址</span><br><span class="line">   total_mem_bytes dd 0					 </span><br><span class="line">   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">   ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span><br><span class="line">   gdt_ptr  dw  GDT_LIMIT </span><br><span class="line">	    dd  GDT_BASE</span><br><span class="line"></span><br><span class="line">   ;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节</span><br><span class="line">   ards_buf times 244 db 0</span><br><span class="line">   ards_nr dw 0		      ;用于记录ards结构体数量</span><br><span class="line"></span><br><span class="line">   loader_start:</span><br><span class="line">   </span><br><span class="line">;-------  int 15h eax &#x3D; 0000E820h ,edx &#x3D; 534D4150h (&#39;SMAP&#39;) 获取内存布局  -------</span><br><span class="line"></span><br><span class="line">   xor ebx, ebx		      ;第一次调用时，ebx值要为0</span><br><span class="line">   mov edx, 0x534d4150	  ;edx只赋值一次，循环体中不会改变</span><br><span class="line">   mov di, ards_buf	      ;ards结构缓冲区</span><br><span class="line">.e820_mem_get_loop:	      ;循环获取每个ARDS内存范围描述结构</span><br><span class="line">   mov eax, 0x0000e820	  ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span><br><span class="line">   mov ecx, 20		      ;ARDS地址范围描述符结构大小是20字节</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e820_failed_so_try_e801   ;若cf位为1则有错误发生，尝试0xe801子功能</span><br><span class="line">   add di, cx		      ;使di增加20字节指向缓冲区中新的ARDS结构位置</span><br><span class="line">   inc word [ards_nr]	  ;记录ARDS数量</span><br><span class="line">   cmp ebx, 0		      ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span><br><span class="line">   jnz .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span><br><span class="line">   mov cx, [ards_nr]	  ;遍历每一个ARDS结构体,循环次数是ARDS的数量</span><br><span class="line">   mov ebx, ards_buf </span><br><span class="line">   xor edx, edx		      ;edx为最大的内存容量,在此先清0</span><br><span class="line">.find_max_mem_area:	      ;无须判断type是否为1,最大的内存块一定是可被使用</span><br><span class="line">   mov eax, [ebx]	      ;base_add_low</span><br><span class="line">   add eax, [ebx+8]	      ;length_low</span><br><span class="line">   add ebx, 20		      ;指向缓冲区中下一个ARDS结构</span><br><span class="line">   cmp edx, eax		      ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span><br><span class="line">   jge .next_ards</span><br><span class="line">   mov edx, eax		      ;edx为总内存大小</span><br><span class="line">.next_ards:</span><br><span class="line">   loop .find_max_mem_area</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;------  int 15h ax &#x3D; E801h 获取内存大小,最大支持4G  ------</span><br><span class="line">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span><br><span class="line">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span><br><span class="line">.e820_failed_so_try_e801:</span><br><span class="line">   mov ax,0xe801</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e801_failed_so_try88   ;若当前e801方法失败,就尝试0x88方法</span><br><span class="line"></span><br><span class="line">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span><br><span class="line">   mov cx,0x400	     ;cx和ax值一样,cx用做乘数</span><br><span class="line">   mul cx </span><br><span class="line">   shl edx,16</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">   or edx,eax</span><br><span class="line">   add edx, 0x100000 ;ax只是15MB,故要加1MB</span><br><span class="line">   mov esi,edx	     ;先把低15MB的内存容量存入esi寄存器备份</span><br><span class="line"></span><br><span class="line">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span><br><span class="line">   xor eax,eax</span><br><span class="line">   mov ax,bx		</span><br><span class="line">   mov ecx, 0x10000	;0x10000十进制为64KB</span><br><span class="line">   mul ecx		    ;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span><br><span class="line">   add esi,eax		;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span><br><span class="line">   mov edx,esi		;edx为总内存大小</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;-----------------  int 15h ah &#x3D; 0x88 获取内存大小,只能获取64M之内  ----------</span><br><span class="line">.e801_failed_so_try88: </span><br><span class="line">   ;int 15后，ax存入的是以kb为单位的内存容量</span><br><span class="line">   mov  ah, 0x88</span><br><span class="line">   int  0x15</span><br><span class="line">   jc .error_hlt</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">      </span><br><span class="line">   ;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span><br><span class="line">   mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位</span><br><span class="line">   mul cx</span><br><span class="line">   shl edx, 16	     ;把dx移到高16位</span><br><span class="line">   or edx, eax	     ;把积的低16位组合到edx,为32位的积</span><br><span class="line">   add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span><br><span class="line"></span><br><span class="line">.mem_get_ok:</span><br><span class="line">   mov [total_mem_bytes], edx	 ;将内存换为byte单位后存入total_mem_bytes处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-----------------   准备进入保护模式   -------------------</span><br><span class="line">;1 打开A20</span><br><span class="line">;2 加载gdt</span><br><span class="line">;3 将cr0的pe位置1</span><br><span class="line"></span><br><span class="line">   ;-----------------  打开A20  ----------------</span><br><span class="line">   in al,0x92</span><br><span class="line">   or al,0000_0010B</span><br><span class="line">   out 0x92,al</span><br><span class="line"></span><br><span class="line">   ;-----------------  加载GDT  ----------------</span><br><span class="line">   lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   ;-----------------  cr0第0位置1  ----------------</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x00000001</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   jmp dword SELECTOR_CODE:p_mode_start	   ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span><br><span class="line">					                     ; 这将导致之前做的预测失效，从而起到了刷新的作用。</span><br><span class="line">.error_hlt:		      ;出错则挂起</span><br><span class="line">   hlt</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">   mov ax, SELECTOR_DATA</span><br><span class="line">   mov ds, ax</span><br><span class="line">   mov es, ax</span><br><span class="line">   mov ss, ax</span><br><span class="line">   mov esp,LOADER_STACK_TOP</span><br><span class="line">   mov ax, SELECTOR_VIDEO</span><br><span class="line">   mov gs, ax</span><br><span class="line"></span><br><span class="line">   mov byte [gs:160], &#39;P&#39;</span><br><span class="line"></span><br><span class="line">   jmp $</span><br></pre></td></tr></table></figure>

<p>在<code>mbr.S</code>中也需要修改一处内容，我们跳转的内容要加上0x300，原因是在 loader.S 中<code>loader_start</code>计算如下</p>
<blockquote>
<p>(4个段描述符 + 60个段描述符槽位) * 8字节 = total_mem_bytes_offset</p>
<p>(4 + 60) * 8 = 512 = 0x200</p>
<p>total_mem_bytes + gdt_ptr + ards_buf + adrs_nr + total_mem_bytes_offset = loader_start</p>
<p>4 + 6 + 244 + 2 + 0x200 = 0x300</p>
</blockquote>
<p>修改片断如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[...] </span><br><span class="line">   mov eax,LOADER_START_SECTOR</span><br><span class="line">   mov bx,LOADER_BASE_ADDR</span><br><span class="line">   mov cx,4</span><br><span class="line">   call rd_disk_m_16</span><br><span class="line">  </span><br><span class="line">   jmp LOADER_BASE_ADDR+0x300 ; 这里</span><br><span class="line"></span><br><span class="line">rd_disk_m_16:	   </span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">添加个库目录 + 编译</span><br><span class="line">--nasm -I include&#x2F; -o mbr.bin mbr.S  </span><br><span class="line">下面将生成的 mbr.bin 写入我们的虚拟硬盘，还是用 dd 命令。</span><br><span class="line">--sudo dd if&#x3D;&#x2F;your_path&#x2F;mbr.bin of&#x3D;&#x2F;your_path&#x2F;bochs&#x2F;hd60M.img bs&#x3D;512 count&#x3D;1 conv&#x3D;notrunc</span><br><span class="line">--sudo dd if&#x3D;&#x2F;home&#x2F;fyz&#x2F;sc&#x2F;bochs-2.6.2&#x2F;mbr.bin of&#x3D;&#x2F;home&#x2F;fyz&#x2F;sc&#x2F;bochs-2.6.2&#x2F;hd60M.img bs&#x3D;512 count&#x3D;1 conv&#x3D;notrunc</span><br><span class="line"></span><br><span class="line">记录了1+0 的读入</span><br><span class="line">记录了1+0 的写出</span><br><span class="line">512 bytes copied, 0.000546068 s, 938 kB&#x2F;s</span><br><span class="line"></span><br><span class="line">添加个库目录 + 编译</span><br><span class="line">--nasm -I include&#x2F; -o loader.bin loader.S</span><br><span class="line">将生成的 loader.bin 写入硬盘第 2 个扇区。第 0 个扇区是 MBR，第 1 个扇区是空的未使用。（ 我就喜欢 你咋的</span><br><span class="line">--sudo dd if&#x3D;.&#x2F;loader.bin of&#x3D;&#x2F;your_path&#x2F;bochs&#x2F;hd60M.img bs&#x3D;512 count&#x3D;2 seek&#x3D;2 conv&#x3D;notrunc</span><br><span class="line">--sudo dd if&#x3D;.&#x2F;loader.bin of&#x3D;&#x2F;home&#x2F;fyz&#x2F;sc&#x2F;bochs-2.6.2&#x2F;hd60M.img bs&#x3D;512 count&#x3D;2 seek&#x3D;2 conv&#x3D;notrunc</span><br><span class="line">（由于是1000字节大小 所以 count&#x3D;2</span><br><span class="line"></span><br><span class="line">记录了1+1 的读入</span><br><span class="line">记录了1+1 的写出</span><br><span class="line">1000 bytes (1.0 kB) copied, 0.000761711 s, 1.3 MB&#x2F;s</span><br></pre></td></tr></table></figure>

<p>运行结果如下，这里我们用<code>xp 0xb00</code>查看我们的结果，<code>0x02000000</code>换算过来刚好是我们<code>bochsrc.disk</code>中 megs 设置的32MB大小</p>
<p> <img src="https://inews.gtimg.com/newsapp_ls/0/13190601444/0" alt="image-20201022204208877"></p>
<h2 id="启动分页机制"><a href="#启动分页机制" class="headerlink" title="启动分页机制"></a>启动分页机制</h2><p>分页机制是当物理内存不足时，或者内存碎片过多无法容纳新进程等情况的一种应对措施。假如说此时未开启分页功能，而物理内存空间又不足，如下图所示.</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601464/0" alt="image-20201023164539146"> </p>
<p>此时进程C想要执行，但是内存空间已经不足。要么就等待进程A或者进程B执行完成，这样就有连续的内存空间了。要么就讲进程A的A3段或者进程B的B1段换到硬盘上，腾出一部分空间，同样可以容纳进程C执行.</p>
<p>等待是极其不好的用户体验，那么只能将段置换到硬盘上了，但是段的大小并不固定，如何段过大，那么IO操作过多，机器的响应速度就会非常慢。</p>
<p>出现这种情况的本质其实是在分段机制下，线性地址等价于物理地址。那么即使在进程B的下面还有10M的可用空间，但因为两块可用空间并不连续，所以进程C无法使用进程B下面的10M可用空间。</p>
<p>按照这种思路，只需要通过某种映射关系，将线性地址映射到任意的物理地址，就可以解决这种问题了。实现线性地址的连续，而物理地址不需要连续，于是分页机制就诞生了。</p>
<h3 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h3><p>尽管在保护模式中段寄存器中的内容已经是选择子，但选择子最终就是为了要找到段基址，其内存访问的核心机制依然是<strong>“段基址：段内偏移地址”</strong>，这两个地址在相加之后才是绝对地址，也就是我们所说的<strong>线性地址</strong>，此线性地址在分段机制下被 CPU 认为是物理地址，直接拿来就能用，也就是说，此线性地址可以直接送上地址总线。</p>
<p>分页机制是工作在分段机制下的，在保护模式下，通过选择子找到段基址，通过段基址：段内偏移的方式组合成线性地址，拿到线性地址之后会根据是否开启分页来找到实际的物理地址。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601480/0" alt="image-20201023165737231"></p>
<p>分页机制的思想是：通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑上连续的线性地址其对应的物理地址可以不连续。</p>
<p>分页机制的作用有两方面。</p>
<blockquote>
<p>1.将线性地址转换成物理地址。<br>2.用大小相等的页代替大小不等的段</p>
</blockquote>
<p>如图所示：</p>
<p>需要通过分页机制来映射的线性地址便是我们通常叫的 <strong>虚拟地址</strong></p>
<p> <img src="https://inews.gtimg.com/newsapp_ls/0/13190601496/0" alt="image-20201023170120868"></p>
<p>我们需要平衡页的大小与页的数量的关系，因为<strong>页大小*页数量=4GB</strong>，想要减少页表的大小，只能增加一页的大小。最终通过数学求极限，定下4KB为最佳页大小。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601509/0" alt="image-20201023171618309"> </p>
<p>这种情况下，4GB的内存被划分为1MB个内存块，每个内存块的大小为4KB。</p>
<p>页表和内存的映射关系如图</p>
<p> <img src="https://inews.gtimg.com/newsapp_ls/0/13190601543/0" alt="image-20201023171819242"></p>
<p>页部件的工作：用线性地址的高 20 位在页表中索引页表项，用线性地址的低 12 位与页表项中的物理地址相加，所求的和便是最终线性地址对应的物理地址。</p>
<p>例如 mov ax，[0x1234] 。</p>
<p> <img src="https://inews.gtimg.com/newsapp_ls/0/13190601561/0" alt="image-20201023172031920"></p>
<h3 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h3><p>无论是几级页表，标准页的尺寸都是4KB。所以4GB的线性地址空间最多有1M个标准页。一级页表是将这1M个标准页放置到一张页表中，二级页表是将这1M个标准页平均放置1K个页表中，每个页表包含有1K个页表项。页表项是4字节大小，页表包含1K个页表项，故页表的大小同样为4KB，刚好为一页。</p>
<p>为了管理页表的物理地址，专门有一个页目录表来存放这些页表。页目录表中存储的页表称为页目录项(PDE)，页目录项同样为4KB，且最多有1K个页目录项，所以页目录表也是4KB，如下图所示</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601595/0" alt="image-20201023201356840"> </p>
<p>二级页表中虚拟地址到物理地址的转换也有很大的变化，具体步骤如下</p>
<ul>
<li><p>用虚拟地址的高 10 位乘以 4，作为页目录表内的偏移地址，加上页目录表的物理地址，所得的和，便是页目录项的物理地址。读取该页目录项，从中获取到页表的物理地址。</p>
</li>
<li><p>用虚拟地址的中间 10 位乘以 4，作为页表内的偏移地址，加上在第 1 步中得到的页表物理地址，所得的和，便是页表项的物理地址。读取该页表项，从中获取到分配的物理页地址。</p>
</li>
<li><p>虚拟地址的高 10 位和中间 10 位分别是 PDE PIE 的索引值，所以它们需要乘以 4。但低 12 位就不是索引值了，其表示的范围是 0~0xfff，作为页内偏移最合适，所以虚拟地址的低 12 位加上第二步中得到的物理页地址，所得的和便是最终转换的物理地址。</p>
<p>下图表示<code>mov ax, [0x1234567]</code>的转换过程，可以发现cr3寄存器其实指向的是页目录表基地址</p>
</li>
</ul>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601624/0" alt="image-20201023201922880"></p>
<p>PDE和PTE的结构如下图所示</p>
<p> <img src="https://inews.gtimg.com/newsapp_ls/0/13190601644/0" alt="image-20201023202117714"></p>
<p>从右到左各属性总结如下表</p>
<table>
<thead>
<tr>
<th>属性位</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td>P</td>
<td align="left">存在位，为1时表示该页在物理内存中，为0表示不在物理内存中</td>
</tr>
<tr>
<td>RW</td>
<td align="left">读写位，为1时可读可写，为0是可读不可写</td>
</tr>
<tr>
<td>US</td>
<td align="left">特权位，为1时表示处于普通用户，0<del>3特权级可访问，为0表示超级用户，0</del>2特权级可访问</td>
</tr>
<tr>
<td>PWT</td>
<td align="left">页级通写位，为1表示此项采用通写方式，表示该页不仅是普通内存，还是高速缓存</td>
</tr>
<tr>
<td>PCD</td>
<td align="left">页级高速缓存禁止位，为1表示该页启用高速缓存</td>
</tr>
<tr>
<td>A</td>
<td align="left">访问位，为1表示该页被CPU访问过</td>
</tr>
<tr>
<td>D</td>
<td align="left">脏页位，当CPU对一个页面执行写操作，此为被赋1</td>
</tr>
<tr>
<td>PAT</td>
<td align="left">页属性表位，能够在页面一级的粒度上设置内存属性</td>
</tr>
<tr>
<td>G</td>
<td align="left">全局位，为1表示该页在高速缓存TLB中一直保存</td>
</tr>
<tr>
<td>AVL</td>
<td align="left">表示软件，系统可用该位，和CPU无关</td>
</tr>
</tbody></table>
<p><strong>启用分页机制</strong>，我们要按顺序做好三件事。 </p>
<p>（1）准备好页目录表及页表。<br>（2）将页表地址写入控制寄存器 cr3。<br>（3）寄存器 cr0 的 PG 位置 1。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601668/0" alt="image-20201023204710038"> </p>
<blockquote>
<p><strong>CR0</strong> 是系统内的控制寄存器之一。控制寄存器是一些特殊的寄存器，它们可以控制CPU的一些重要特性。<br><strong>第 0 位</strong>是<strong>保护允许位PE</strong>(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。<br><strong>第 1 位</strong>是<strong>监控协处理位MP</strong>(Moniter coprocessor)，它与第3位一起决定：当TS=1时操作码WAIT是否产生一个“协处理器不能使用”的出错信号。<br><strong>第 2 位</strong>是<strong>模拟协处理器位EM</strong> (Emulate coprocessor)，如果EM=1，则不能使用协处理器，如果EM=0，则允许使用协处理器。<br><strong>第 3 位</strong>是<strong>任务转换位TS</strong>(Task Switch)，当一个任务转换完成之后，自动将它置1。随着TS=1，就不能使用协处理器。<br><strong>第 4 位</strong>是<strong>微处理器的扩展类型位 ET</strong>(Processor Extension Type)，其内保存着处理器扩展类型的信息，如果ET=0，则标识系统使<br>用的是287协处理器，如果 ET=1，则表示系统使用的是387浮点协处理器。<br><strong>第16位</strong>是<strong>写保护未即WP位</strong>(486系列之后)，只要将这一位置0就可以禁用写保护，置1则可将其恢复<br><strong>第31位</strong>是<strong>分页允许位PG</strong>(Paging Enable)，它表示芯片上的分页部件是否允许工作。</p>
<p><strong>CR1</strong>是未定义的控制寄存器，供将来的处理器使用。<br><strong>CR2</strong>是页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址。<br><strong>CR3</strong>是页目录基址寄存器，保存页目录表的物理地址，页目录表总是放在以4K字节为单位的存储器边界上，因此，它的地址的低12位总为0，不起作用，即使写上内容，也不会被理会。<br><strong>CR4</strong>在Pentium系列（包括486的后期版本）处理器中才实现，它处理的事务包括诸如何时启用虚拟8086模式等</p>
</blockquote>
<h3 id="启动分页机制-1"><a href="#启动分页机制-1" class="headerlink" title="启动分页机制"></a>启动分页机制</h3><p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601688/0" alt="image-20201109200141630"> </p>
<p>创建页目录及页表的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">; 创建页目录及页表</span><br><span class="line">setup_page:</span><br><span class="line">; 先把页目录占用的空间逐字节清零</span><br><span class="line">	mov ecx, 4096</span><br><span class="line">	mov esi, 0</span><br><span class="line">.clear_page_dir:</span><br><span class="line">	mov byte [PAGE_DIR_TABLE_POS + esi], 0</span><br><span class="line">	inc esi</span><br><span class="line">	loop .clear_page_dir</span><br><span class="line"></span><br><span class="line">; 开始创建页目录项(PDE)</span><br><span class="line">.create_pde:        ; 创建PDE</span><br><span class="line">	mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">	add eax, 0x1000 ; 此时eax为第一个页表的位置及属性</span><br><span class="line">	mov ebx, eax    ; 此处为ebx赋值,是为.create_pte做准备,ebx为基址</span><br><span class="line"></span><br><span class="line">; 下面将页目录项0和0xc00都存为第一个页表的地址，每个页表表示4MB内存</span><br><span class="line">; 这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表</span><br><span class="line">; 这是为将地址映射为内核地址做准备</span><br><span class="line">	or eax, PG_US_U | PG_RW_W | PG_P      ; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span><br><span class="line">	mov [PAGE_DIR_TABLE_POS + 0x0], eax   ; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(7)</span><br><span class="line">	mov [PAGE_DIR_TABLE_POS + 0xc00], eax ; 一个页表项占用四字节</span><br><span class="line">	; 0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间</span><br><span class="line">	; 也就是页表的0xc0000000~0xffffffff这1G属于内核</span><br><span class="line">	; 0x0~0xbfffffff这3G属于用户进程</span><br><span class="line">	sub eax, 0x1000</span><br><span class="line">	mov [PAGE_DIR_TABLE_POS + 4092], eax  ; 使最后一个目录项指向页目录表自己的地址</span><br><span class="line">	</span><br><span class="line">; 下面创建页表项(PTE)</span><br><span class="line">	mov ecx, 256	; 1M低端内存 &#x2F; 每页大小 4K &#x3D; 256</span><br><span class="line">	mov esi, 0</span><br><span class="line">	mov edx, PG_US_U | PG_RW_W | PG_P	; 属性为7</span><br><span class="line">.create_pte:		; 创建PTE</span><br><span class="line">	mov [ebx+esi*4], edx ; 此时的edx为0x101000,也就是第一个页表的地址</span><br><span class="line">	add edx, 4096</span><br><span class="line">	inc esi</span><br><span class="line">	loop .create_pte</span><br><span class="line"></span><br><span class="line">; 创建内核其他页表的PDE</span><br><span class="line">	mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">	add eax, 0x2000						; 此时eax为第二个页表的位置</span><br><span class="line">	or eax, PG_US_U | PG_RW_W | PG_P	; 属性为7</span><br><span class="line">	mov ebx, PAGE_DIR_TABLE_POS</span><br><span class="line">	mov ecx, 254						; 范围为第769~1022的所有目录项数量</span><br><span class="line">	mov esi, 769</span><br><span class="line">.create_kernel_pde:</span><br><span class="line">	mov [ebx+esi*4], eax</span><br><span class="line">    inc esi</span><br><span class="line">    add eax, 0x1000</span><br><span class="line">    loop .create_kernel_pde</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>在boot.inc中添加如下信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; loader 和 kernel</span><br><span class="line">PAGE_DIR_TABLE_POS equ 0x100000</span><br><span class="line">; 页表相关属性</span><br><span class="line">PG_P equ 1b</span><br><span class="line">PG_RW_R equ 00b</span><br><span class="line">PG_RW_W equ 10b</span><br><span class="line">PG_US_S equ 000b</span><br><span class="line">PG_US_U equ 100b</span><br></pre></td></tr></table></figure>

<p>行完第一步的内容，之后的操作相对就简单了，将页表地址写入控制寄存器cr3寄存器和将cr0的PG位置1的操作整合起来的<code>loader.S</code>如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">section loader vstart&#x3D;LOADER_BASE_ADDR</span><br><span class="line">LOADER_STACK_TOP equ LOADER_BASE_ADDR</span><br><span class="line"></span><br><span class="line">;构建gdt及其内部的描述符</span><br><span class="line">GDT_BASE:   dd    0x00000000 </span><br><span class="line">            dd    0x00000000</span><br><span class="line"></span><br><span class="line">CODE_DESC:  dd    0x0000FFFF </span><br><span class="line">            dd    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line">DATA_STACK_DESC:  dd    0x0000FFFF</span><br><span class="line">	              dd    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line">VIDEO_DESC: dd    0x80000007	   ; limit&#x3D;(0xbffff-0xb8000)&#x2F;4k&#x3D;0x7</span><br><span class="line">            dd    DESC_VIDEO_HIGH4  ; 此时dpl为0</span><br><span class="line"></span><br><span class="line">GDT_SIZE   equ   $ - GDT_BASE</span><br><span class="line">GDT_LIMIT   equ   GDT_SIZE -	1 </span><br><span class="line">times 60 dq 0					 ; 此处预留60个描述符的空位(slot)</span><br><span class="line">SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0     ; 相当于(CODE_DESC - GDT_BASE)&#x2F;8 + TI_GDT + RPL0</span><br><span class="line">SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0	 ; 同上</span><br><span class="line">SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0	 ; 同上 </span><br><span class="line"></span><br><span class="line">; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。</span><br><span class="line">; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,</span><br><span class="line">; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址</span><br><span class="line">total_mem_bytes dd 0					 </span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span><br><span class="line">gdt_ptr  dw  GDT_LIMIT </span><br><span class="line">    dd  GDT_BASE</span><br><span class="line"></span><br><span class="line">;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节</span><br><span class="line">ards_buf times 244 db 0</span><br><span class="line">ards_nr dw 0		      ;用于记录ards结构体数量</span><br><span class="line"></span><br><span class="line">loader_start:</span><br><span class="line"></span><br><span class="line">;-------  int 15h eax &#x3D; 0000E820h ,edx &#x3D; 534D4150h (&#39;SMAP&#39;) 获取内存布局  -------</span><br><span class="line"></span><br><span class="line">   xor ebx, ebx		      ;第一次调用时，ebx值要为0</span><br><span class="line">   mov edx, 0x534d4150	  ;edx只赋值一次，循环体中不会改变</span><br><span class="line">   mov di, ards_buf	      ;ards结构缓冲区</span><br><span class="line">.e820_mem_get_loop:	      ;循环获取每个ARDS内存范围描述结构</span><br><span class="line">   mov eax, 0x0000e820	  ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span><br><span class="line">   mov ecx, 20		      ;ARDS地址范围描述符结构大小是20字节</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e820_failed_so_try_e801   ;若cf位为1则有错误发生，尝试0xe801子功能</span><br><span class="line">   add di, cx		      ;使di增加20字节指向缓冲区中新的ARDS结构位置</span><br><span class="line">   inc word [ards_nr]	  ;记录ARDS数量</span><br><span class="line">   cmp ebx, 0		      ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span><br><span class="line">   jnz .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span><br><span class="line">   mov cx, [ards_nr]	  ;遍历每一个ARDS结构体,循环次数是ARDS的数量</span><br><span class="line">   mov ebx, ards_buf </span><br><span class="line">   xor edx, edx		      ;edx为最大的内存容量,在此先清0</span><br><span class="line">.find_max_mem_area:	      ;无须判断type是否为1,最大的内存块一定是可被使用</span><br><span class="line">   mov eax, [ebx]	      ;base_add_low</span><br><span class="line">   add eax, [ebx+8]	      ;length_low</span><br><span class="line">   add ebx, 20		      ;指向缓冲区中下一个ARDS结构</span><br><span class="line">   cmp edx, eax		      ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span><br><span class="line">   jge .next_ards</span><br><span class="line">   mov edx, eax		      ;edx为总内存大小</span><br><span class="line">.next_ards:</span><br><span class="line">   loop .find_max_mem_area</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;------  int 15h ax &#x3D; E801h 获取内存大小,最大支持4G  ------</span><br><span class="line">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span><br><span class="line">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span><br><span class="line">.e820_failed_so_try_e801:</span><br><span class="line">   mov ax,0xe801</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e801_failed_so_try88   ;若当前e801方法失败,就尝试0x88方法</span><br><span class="line"></span><br><span class="line">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span><br><span class="line">   mov cx,0x400	     ;cx和ax值一样,cx用做乘数</span><br><span class="line">   mul cx </span><br><span class="line">   shl edx,16</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">   or edx,eax</span><br><span class="line">   add edx, 0x100000 ;ax只是15MB,故要加1MB</span><br><span class="line">   mov esi,edx	     ;先把低15MB的内存容量存入esi寄存器备份</span><br><span class="line"></span><br><span class="line">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span><br><span class="line">   xor eax,eax</span><br><span class="line">   mov ax,bx		</span><br><span class="line">   mov ecx, 0x10000	;0x10000十进制为64KB</span><br><span class="line">   mul ecx		    ;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span><br><span class="line">   add esi,eax		;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span><br><span class="line">   mov edx,esi		;edx为总内存大小</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;-----------------  int 15h ah &#x3D; 0x88 获取内存大小,只能获取64M之内  ----------</span><br><span class="line">.e801_failed_so_try88: </span><br><span class="line">   ;int 15后，ax存入的是以kb为单位的内存容量</span><br><span class="line">   mov  ah, 0x88</span><br><span class="line">   int  0x15</span><br><span class="line">   jc .error_hlt</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">      </span><br><span class="line">   ;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span><br><span class="line">   mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位</span><br><span class="line">   mul cx</span><br><span class="line">   shl edx, 16	     ;把dx移到高16位</span><br><span class="line">   or edx, eax	     ;把积的低16位组合到edx,为32位的积</span><br><span class="line">   add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span><br><span class="line"></span><br><span class="line">.mem_get_ok:</span><br><span class="line">   mov [total_mem_bytes], edx	 ;将内存换为byte单位后存入total_mem_bytes处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-----------------   准备进入保护模式   -------------------</span><br><span class="line">;1 打开A20</span><br><span class="line">;2 加载gdt</span><br><span class="line">;3 将cr0的pe位置1</span><br><span class="line"></span><br><span class="line">   ;-----------------  打开A20  ----------------</span><br><span class="line">   in al,0x92</span><br><span class="line">   or al,0000_0010B</span><br><span class="line">   out 0x92,al</span><br><span class="line"></span><br><span class="line">   ;-----------------  加载GDT  ----------------</span><br><span class="line">   lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   ;-----------------  cr0第0位置1  ----------------</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x00000001</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   jmp dword SELECTOR_CODE:p_mode_start	   ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span><br><span class="line">					                     ; 这将导致之前做的预测失效，从而起到了刷新的作用。</span><br><span class="line">.error_hlt:		      ;出错则挂起</span><br><span class="line">   hlt</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">   mov ax, SELECTOR_DATA</span><br><span class="line">   mov ds, ax</span><br><span class="line">   mov es, ax</span><br><span class="line">   mov ss, ax</span><br><span class="line">   mov esp,LOADER_STACK_TOP</span><br><span class="line">   mov ax, SELECTOR_VIDEO</span><br><span class="line">   mov gs, ax</span><br><span class="line"></span><br><span class="line">   ; 创建页目录及页表并初始化内存位图</span><br><span class="line">   call setup_page</span><br><span class="line">  </span><br><span class="line">   ; 要将描述符表地址及偏移量写入内存gdt_ptr,一会儿用新地址重新加载</span><br><span class="line">   sgdt [gdt_ptr] ; 储存到原来gdt所有位置</span><br><span class="line">   </span><br><span class="line">   ; 将gdt描述符中视频段描述符中的段基址+0xc0000000</span><br><span class="line">   mov ebx, [gdt_ptr + 2] ; gdt地址</span><br><span class="line">   or dword [ebx + 0x18 + 4], 0xc0000000</span><br><span class="line">   ; 视频段是第3个段描述符,每个描述符是8字节,故0x18</span><br><span class="line">   ; 段描述符的高4字节的最高位是段基址的第31~24位</span><br><span class="line">   </span><br><span class="line">   ; 将gdt的基址加上0xc0000000使其成为内核所在的高地址</span><br><span class="line">   add dword [gdt_ptr + 2], 0xc0000000</span><br><span class="line">   add esp, 0xc0000000 ; 将栈指针同样映射到内核地址</span><br><span class="line"></span><br><span class="line">   ; 把页目录地址赋给cr3</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   mov cr3, eax</span><br><span class="line">   </span><br><span class="line">   ; 打开cr0的pg位(第31位)</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x80000000</span><br><span class="line">   mov cr0, eax</span><br><span class="line">   </span><br><span class="line">   ; 在开启分页后，用gdt新的地址重新加载</span><br><span class="line">   lgdt [gdt_ptr] ; 重新加载</span><br><span class="line">   </span><br><span class="line">   mov byte [gs:160], &#39;V&#39;</span><br><span class="line">   ; 视频段段基址已经被更新,用字符V表示virtual addr</span><br><span class="line">   jmp $</span><br><span class="line">   </span><br><span class="line">;-------------   创建页目录及页表   ---------------</span><br><span class="line">; 创建页目录以及页表</span><br><span class="line">setup_page:</span><br><span class="line">    ; 页目录表占据4KB空间，清零之</span><br><span class="line">    mov ecx, 4096</span><br><span class="line">    mov esi, 0</span><br><span class="line">.clear_page_dir:   </span><br><span class="line">    mov byte [PAGE_DIR_TABLE_POS + esi], 0</span><br><span class="line">    inc esi</span><br><span class="line">    loop .clear_page_dir</span><br><span class="line"></span><br><span class="line">; 创建页目录表(PDE)</span><br><span class="line">.create_pde:</span><br><span class="line">    mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">    ; 0x1000为4KB，加上页目录表起始地址便是第一个页表的地址</span><br><span class="line">    add eax, 0x1000</span><br><span class="line">    mov ebx, eax</span><br><span class="line"></span><br><span class="line">    ; 设置页目录项属性</span><br><span class="line">    or eax, PG_US_U | PG_RW_W | PG_P</span><br><span class="line">    ; 设置第一个页目录项</span><br><span class="line">    mov [PAGE_DIR_TABLE_POS], eax</span><br><span class="line">    ; 第768(内核空间的第一个)个页目录项，与第一个相同，这样第一个和768个都指向低端4MB空间</span><br><span class="line">    mov [PAGE_DIR_TABLE_POS + 0xc00], eax</span><br><span class="line">    ; 最后一个表项指向自己，用于访问页目录本身</span><br><span class="line">    sub eax, 0x1000</span><br><span class="line">    mov [PAGE_DIR_TABLE_POS + 4092], eax</span><br><span class="line"></span><br><span class="line">; 创建页表</span><br><span class="line">    mov ecx, 256</span><br><span class="line">    mov esi, 0</span><br><span class="line">    mov edx, PG_US_U | PG_RW_W | PG_P</span><br><span class="line">.create_pte:</span><br><span class="line">    mov [ebx + esi * 4], edx</span><br><span class="line">    add edx, 4096</span><br><span class="line">    inc esi</span><br><span class="line">    loop .create_pte</span><br><span class="line"></span><br><span class="line">; 创建内核的其它PDE</span><br><span class="line">    mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">    add eax, 0x2000</span><br><span class="line">    or eax, PG_US_U | PG_RW_W | PG_P </span><br><span class="line">    mov ebx, PAGE_DIR_TABLE_POS</span><br><span class="line">    mov ecx, 254</span><br><span class="line">    mov esi, 769</span><br><span class="line">.create_kernel_pde:</span><br><span class="line">    mov [ebx + esi * 4], eax</span><br><span class="line">    inc esi</span><br><span class="line">    add eax, 0x1000</span><br><span class="line">    loop .create_kernel_pde</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>运行之后 （ 已成功</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601706/0" alt="image-20201109210146952"> </p>
<p>运行结果如下图，其中 gdt段基址 已经修改为大于 0xc0000000，也就是3GB之上的内核地址空间，通过<code>info tab</code>可查看地址映射关系，其中箭头左边是虚拟地址，右边是对应的物理地址</p>
<p> <img src="https://inews.gtimg.com/newsapp_ls/0/13190601728/0" alt="image-20201109210300503"></p>
<p>总结虚拟地址获取物理地址的过程：</p>
<p>先要从 CR3 寄存器中获取页目录表物理地址，然后用虚拟地址的高 10 位乘以 4 的积作为在页目录表中的偏移量去寻址目录项 pde ，从 pde 中读出页表物理地址，然后再用虚拟地址的中间 10 位乘以 4 的积作为在该页表中的偏移量去寻址页表项 pte，从该 pte 中读出页框物理地址，用虚拟地址的低 12 位作为该物理页框的偏移量。</p>
<p>总结用虚拟地址获取页表中各数据类型的方法：</p>
<p>获取页目录表物理地址：让虚拟地址的高 20 位为 0xfffff，低 12 位为 0x000，即 0xfffff000，这也是页目录表中第 0 个页目录项自身的物理地址。<br>访问页目录中的页目录项，即获取页表物理地址：要使虚拟地址为 0xfffffxxx，其中 xxx 是页目录 项的索引乘以 4 的积。<br>访问页表中的页表项：要使虚拟地址高 10 位为 0x3ff，目的是获取页目录表物理地址。中间 10 位 为页表的索引，因为是 10 位的索引值，所以这里不用乘以 4。低 12 位为页表内的偏移地址，用来定位页 表项，它必须是已经乘以 4 后的值。 公式为 0x3ff&lt;&lt;22+中间 10 位&lt;&lt;12+低 12 位。</p>
<h3 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表 TLB"></a>快表 TLB</h3><p>TLB，即 Translation Lookaside Buffer，俗称快表 ：处理器准备了一个高速缓存，可以匹配高速的处理器速率和低速的内存访问速度，它专门用来存放虚拟地址页框与物理地址页框的映射关系。（ 调整缓存</p>
<p> <img src="https://inews.gtimg.com/newsapp_ls/0/13190601740/0" alt="image-20201110174049306"></p>
<p>TLB 中的条目是虚拟地址的高 20 位到物理地址高 20 位的映射结果，实际上就是从虚拟页框到物理页框的映射。除此之外 TLB 中还有一些属性位，比如页表项的 RW 属性。 有了 TLB，处理器在寻址之前会用虚拟地址的高 20 位作为索引来查找 TLB 中的相关条目，如果命中 （匹配到相关条目）则返回虚拟地址所映射的物理页框地址，否则会查询内存中的页表，获得页框物理地址后再更新 TLB。</p>
<p>更新TLB的方法有两种，<strong>重新加载CR3</strong> 和 <strong>指令<code>invlpg m</code></strong>，其中m表示操作数为虚拟内存地址，如更新虚拟地址0x1234对应的条目指令为<code>invlpg [0x1234]</code>;</p>
<h2 id="ELF格式浅析"><a href="#ELF格式浅析" class="headerlink" title="ELF格式浅析"></a>ELF格式浅析</h2><h3 id="elf格式的二进制文件"><a href="#elf格式的二进制文件" class="headerlink" title="elf格式的二进制文件"></a>elf格式的二进制文件</h3><p>ELF 指的是 Executable and Linkable Format，可执行链接格式。最初是由 UNIX 系统实验室（USL） 作为应用程序二进制接口（ABI）而开发和发行的。工具接口标准委员会（TIS）选择了它作为 IA32 体系 结构上不同操作系统之间的可移植二进制文件格式，于是它就发展成为了事实上的二进制文件格式标准。</p>
<p>elf目标文件有待重定位文件，可共享目标文件，可执行文件。这里重点描述可执行文件。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601770/0" alt="image-20201112212147244"></p>
<h3 id="节、段"><a href="#节、段" class="headerlink" title="节、段"></a>节、段</h3><p><strong>节（section）</strong>是指在汇编源码中由section或segment修饰，的指令区域或者数据区域。不同的汇编器关键字可能不一样。汇编器将这两个关键字修饰的区域在目标文件中编译成节，所以说节是在待重定位文件目标文件时产生的。<br><strong>段（segment）</strong>是链接器根据待重定位文件中属性相同的多个section合并成section集合，这个集合就是段（segment）。链接器最后生成的是可执行文件，所以段是在可执行文件中生成的。平时所说的数据段，代码段就是这里说的segment。</p>
<h3 id="节头表、程序头表、节头、程序头"><a href="#节头表、程序头表、节头、程序头" class="headerlink" title="节头表、程序头表、节头、程序头"></a>节头表、程序头表、节头、程序头</h3><p>一个程序中，节和段的大小和数量是不固定的，所以就需要一个专门的表来描述它们，这个表就是所说的<strong>节头表</strong>（section header table）和<strong>程序头表</strong>（program header table）。节头表中描述的信息是多个节头（section header），段头表中描述的信息是多个段头（program header）。在表中，每一个成员称为条目，及entry，一个条目代表一个段或者一个节的头信息。</p>
<h3 id="elf-header"><a href="#elf-header" class="headerlink" title="elf header"></a>elf header</h3><p>因为程序中的段和节的大小和数量不确定，所以程序头表和节头表的大小就是不确定的，表在程序文件中的存储顺序也是由先后的，所以这两个表的位置也是不确定的。这时就必须在用一个固定的结构来描述这些不确定的信息，这个结构就是elf header，它位于文件最开始的部分。</p>
<blockquote>
<p> elf文件格式作用是在文件链接和运行时方便进行程序的重定位。</p>
</blockquote>
<h3 id="elf-结构"><a href="#elf-结构" class="headerlink" title="elf 结构"></a>elf 结构</h3><p>ELF 格式的作用体现在两方面，一是链接阶段， 另一方面是运行阶段，它们在文件中组织布局从这两方面展示。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601785/0" alt="image-20201112212754030"> </p>
<p>有关elf 的任何定义，包括变量、常量及取值范围，都可以在 Linux 系统的 <strong>/usr/include/elf.h</strong> 中找到，这里面的定义才是最全最权威的。</p>
<h4 id="elf-header-1"><a href="#elf-header-1" class="headerlink" title="elf header"></a>elf header</h4><p>用到的数据类型如下</p>
<table>
<thead>
<tr>
<th align="left">数据类型名称</th>
<th align="left">字节大小</th>
<th align="left">对齐</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Elf32_Half</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">无符号中等大小的整数</td>
</tr>
<tr>
<td align="left">Elf32_Word</td>
<td align="left">4</td>
<td align="left">4</td>
<td align="left">无符号大整数</td>
</tr>
<tr>
<td align="left">Elf32_Addr</td>
<td align="left">4</td>
<td align="left">4</td>
<td align="left">无符号程序运行地址</td>
</tr>
<tr>
<td align="left">Elf32_Off</td>
<td align="left">4</td>
<td align="left">4</td>
<td align="left">无符号的文件偏移量</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;elf header结构</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char	e_ident[EI_NIDENT];	&#x2F;* Magic number and other info *&#x2F; &#x2F;&#x2F;elf文件的魔数</span><br><span class="line">  Elf32_Half	e_type;			&#x2F;&#x2F;elf文件的格式</span><br><span class="line">  Elf32_Half	e_machine;	 &#x2F;&#x2F;描述elf文件的体系结构类型</span><br><span class="line">  Elf32_Word	e_version;		 &#x2F;&#x2F;版本信息</span><br><span class="line">  Elf32_Addr	e_entry;		 &#x2F;&#x2F;操作系统运行程序时,将控制权交到的虚拟地址</span><br><span class="line">  Elf32_Off 	e_phoff;		&#x2F;&#x2F;程序头表在文件内的偏移量</span><br><span class="line">  Elf32_Off	    e_shoff;		&#x2F;&#x2F;节头表在文件内的偏移量</span><br><span class="line">  Elf32_Word	e_flags;		&#x2F;&#x2F;与处理器相关的标志</span><br><span class="line">  Elf32_Half	e_ehsize;		 &#x2F;&#x2F;elf header的大小</span><br><span class="line">  Elf32_Half	e_phentsize;		 &#x2F;&#x2F;程序头表中每个条目的大小</span><br><span class="line">  Elf32_Half	e_phnum;		 &#x2F;&#x2F;程序头表中条目的数量</span><br><span class="line">  Elf32_Half	e_shentsize;		&#x2F;&#x2F;节头表中每个条目的大小</span><br><span class="line">  Elf32_Half	e_shnum;		 &#x2F;&#x2F;节头表中条目的数量</span><br><span class="line">  Elf32_Half	e_shstrndx;		&#x2F;&#x2F;string name table在节头表中的索引</span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># xxd hello的结果，只截取了elf header相关的部分</span><br><span class="line">00000000: 7f45 4c46 0101 0100 0000 0000 0000 0000   .ELF............</span><br><span class="line">00000010: 0300 0300 0100 0000 e003 0000 3400 0000  ............4...</span><br><span class="line">00000020: a817 0000 0000 0000 3400 2000 0900 2800  ........4. ...(.</span><br><span class="line">00000030: 1d00 1c00 0600 0000 3400 0000 3400 0000  ........4...4...</span><br><span class="line"></span><br><span class="line">#readelf -h hello的结果</span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  类别:                              ELF32</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  版本:                              1 (current)</span><br><span class="line">  OS&#x2F;ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              DYN (共享目标文件)</span><br><span class="line">  系统架构:                          Intel 80386</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x3e0</span><br><span class="line">  程序头起点：          52 (bytes into file)</span><br><span class="line">  Start of section headers:          6056 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  本头的大小：       52 (字节)</span><br><span class="line">  程序头大小：       32 (字节)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  节头大小：         40 (字节)</span><br><span class="line">  节头数量：         29</span><br><span class="line">  字符串表索引节头： 28</span><br></pre></td></tr></table></figure>

<p>e_ident [16]是 16 字节大小的数组，用来表示 elf 字符等信息，开头的 4 个字 节是固定不变的，是 elf 文件的魔数，它们分别是 0x7f，以及字符串 ELF 的 ascall 码：0x45, 0x4c, 0x46。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601818/0" alt="image-20201112214041441"></p>
<p>e_ident[5]大小端字节序， 可以利用 <strong>flie</strong> 指令来看。。。</p>
<p><strong>e_type</strong> 占用2字节，指定 elf 目标文件的类型</p>
<table>
<thead>
<tr>
<th align="left">elf目标文件类型</th>
<th align="left">取值</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ET_NONE</td>
<td align="left">0</td>
<td align="left">未知目标文件格式</td>
</tr>
<tr>
<td align="left">ET_REL</td>
<td align="left">1</td>
<td align="left">可重定位文件</td>
</tr>
<tr>
<td align="left">ET_EXEC</td>
<td align="left">2</td>
<td align="left">可执行文件</td>
</tr>
<tr>
<td align="left">ET_DYN</td>
<td align="left">3</td>
<td align="left">动态共享目标文件</td>
</tr>
<tr>
<td align="left">ET_CORE</td>
<td align="left">4</td>
<td align="left">core文件，即程序崩溃时其内存映像的转储格式</td>
</tr>
<tr>
<td align="left">ET_LOPROC</td>
<td align="left">0xff00</td>
<td align="left">特定处理器文件的扩展下边界</td>
</tr>
<tr>
<td align="left">ET_HIPROC</td>
<td align="left">0xffff</td>
<td align="left">特定处理器文件的扩展上边界</td>
</tr>
</tbody></table>
<p>取值为 2 的 ET_EXEC 类型，它的意义为程序可执行.</p>
<p><strong>其余的字段</strong></p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">大小(字节)</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">e_machine</td>
<td align="left">2</td>
<td align="center">支持的硬件平台</td>
</tr>
<tr>
<td align="left">e_version</td>
<td align="left">4</td>
<td align="center">表示版本信息</td>
</tr>
<tr>
<td align="left">e_entry</td>
<td align="left">4</td>
<td align="center">操作系统运行该程序时，将控制权转交到的虚拟地址</td>
</tr>
<tr>
<td align="left">e_phoff</td>
<td align="left">4</td>
<td align="center">程序头表在文件内的字节偏移量。如果没有程序头表，该值为0</td>
</tr>
<tr>
<td align="left">e_shoff</td>
<td align="left">4</td>
<td align="center">节头表在文件内的字节偏移量。若没有节头表，该值为0</td>
</tr>
<tr>
<td align="left">e_flags</td>
<td align="left">4</td>
<td align="center">与处理器相关的标志</td>
</tr>
<tr>
<td align="left">e_ehsize</td>
<td align="left">2</td>
<td align="center">指明 elf header 的字节大小</td>
</tr>
<tr>
<td align="left">e_phentsize</td>
<td align="left">2</td>
<td align="center">指明程序头表(program header table )中每个条目(entry)的字节大小</td>
</tr>
<tr>
<td align="left">e_phnum</td>
<td align="left">2</td>
<td align="center">指明程序头表中条目的数量。实际上就是段的个数</td>
</tr>
<tr>
<td align="left">e_shentsize</td>
<td align="left">2</td>
<td align="center">节头表中每个条目的字节大小，即每个用来描述节信息的数据结构的字节大小</td>
</tr>
<tr>
<td align="left">e_shnum</td>
<td align="left">2</td>
<td align="center">指明节头表中条目的数量。实际上就是节的个数</td>
</tr>
<tr>
<td align="left">e_shstrndx</td>
<td align="left">2</td>
<td align="center">指明 string name table 在节头表中的索引 index</td>
</tr>
</tbody></table>
<p>e_machine 占用 2 字节，用来描述 elf 目标文件的体系结构类型，也就是说该文件要在哪种硬件平台（哪 种机器）上才能运行。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601836/0" alt="image-20201126082647857"> </p>
<h4 id="struct-Elf32-Phd"><a href="#struct-Elf32-Phd" class="headerlink" title="struct Elf32_Phd"></a>struct Elf32_Phd</h4><p>此段是指程序中的某个数据或代码的区域段落，例如数据段或代码段，并不是内存中的段，到现在为止我们都在讨论位于磁盘上的程序文件呢。struct Elf32_Phdr 结构的功能类似 GDT 中段描述符的作用，段描述符用来描述物理内存中的一个内存段，而 struct Elf32_Phdr 是<strong>用来描述位于磁盘上的程序中的一个段</strong>，它被加载到内存后才属于 GDT 中段描述符所指向的内存段的子集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Elf32_Phdr</span><br><span class="line">&#123;</span><br><span class="line">    Elf32_Word p_type;</span><br><span class="line">    Elf32_Off p_offset;</span><br><span class="line">    Elf32_Addr p_vaddr;</span><br><span class="line">    Elf32_Addr p_paddr;</span><br><span class="line">    Elf32_Word p_filesz;</span><br><span class="line">    Elf32_Word p_memsz;</span><br><span class="line">    Elf32_Word p_flags;</span><br><span class="line">    Elf32_Word p_align;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>各个字段意思</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">p_type</td>
<td align="center">段类型</td>
</tr>
<tr>
<td align="left">p_offset</td>
<td align="center">本段在文件的偏移量</td>
</tr>
<tr>
<td align="left">p_vaddr</td>
<td align="center">本段在内存中起始的虚拟地址</td>
</tr>
<tr>
<td align="left">p_paddr</td>
<td align="center">仅用于与物理地址相关的系统中</td>
</tr>
<tr>
<td align="left">p_filesz</td>
<td align="center">本段在文件中的大小</td>
</tr>
<tr>
<td align="left">p_memsz</td>
<td align="center">本段在内存中的大小</td>
</tr>
<tr>
<td align="left">p_flags</td>
<td align="center">本段相关的标志</td>
</tr>
<tr>
<td align="left">p_align</td>
<td align="center">本段在文件和内存中的对齐方式</td>
</tr>
</tbody></table>
<p>p_type 占用 4 字节，用来指明程序中该段的类型。</p>
<p> <img src="https://inews.gtimg.com/newsapp_ls/0/13190601857/0" alt="image-20201126083519569"></p>
<p>p_flag的取值</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601874/0" alt="image-20201126083630966"> </p>
<p>p_align 占用 4 字节，用来指明本段在文件和内存中的对齐方式。如果值为 0 或 1，则表示不对齐。否则 p_align 应该是 2 的幂次数。</p>
<h4 id="ELF32-Shdr"><a href="#ELF32-Shdr" class="headerlink" title="ELF32_Shdr"></a>ELF32_Shdr</h4><p>每个节区头部可以用下面的数据结构进行描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    ELF32_Word      sh_name;</span><br><span class="line">    ELF32_Word      sh_type;</span><br><span class="line">    ELF32_Word      sh_flags;</span><br><span class="line">    ELF32_Addr      sh_addr;</span><br><span class="line">    ELF32_Off       sh_offset;</span><br><span class="line">    ELF32_Word      sh_size;</span><br><span class="line">    ELF32_Word      sh_link;</span><br><span class="line">    ELF32_Word      sh_info;</span><br><span class="line">    ELF32_Word      sh_addralign;</span><br><span class="line">    ELF32_Word      sh_entsize;</span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>成员</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sh_name</td>
<td>节名称，是节区头字符串表节区中（Section Header String Table Section）的索引，因此该字段实际是一个数值。在字符串表中的具体内容是以 NULL 结尾的字符串。</td>
</tr>
<tr>
<td>sh_type</td>
<td>根据节的内容和语义进行分类，具体的类型下面会介绍。</td>
</tr>
<tr>
<td>sh_flags</td>
<td>每一比特代表不同的标志，描述节是否可写，可执行，需要分配内存等属性。</td>
</tr>
<tr>
<td>sh_addr</td>
<td>如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应该在进程镜像中的位置。否则，此字段为 0。</td>
</tr>
<tr>
<td>sh_offset</td>
<td>给出节区的第一个字节与文件开始处之间的偏移。SHT_NOBITS 类型的节区不占用文件的空间，因此其 sh_offset 成员给出的是概念性的偏移。</td>
</tr>
<tr>
<td>sh_size</td>
<td>此成员给出节区的字节大小。除非节区的类型是 SHT_NOBITS ，否则该节占用文件中的 sh_size 字节。类型为 SHT_NOBITS 的节区长度可能非零，不过却不占用文件中的空间。</td>
</tr>
<tr>
<td>sh_link</td>
<td>此成员给出节区头部表索引链接，其具体的解释依赖于节区类型。</td>
</tr>
<tr>
<td>sh_info</td>
<td>此成员给出附加信息，其解释依赖于节区类型。</td>
</tr>
<tr>
<td>sh_addralign</td>
<td>某些节区的地址需要对齐。例如，如果一个节区有一个 doubleword 类型的变量，那么系统必须保证整个节区按双字对齐。也就是说，sh_addr%sh_addralignsh_addr%sh_addralign=0。目前它仅允许为 0，以及 2 的正整数幂数。 0 和 1 表示没有对齐约束。</td>
</tr>
<tr>
<td>sh_entsize</td>
<td>某些节区中存在具有固定大小的表项的表，如符号表。对于这类节区，该成员给出每个表项的字节大小。反之，此成员取值为 0。</td>
</tr>
</tbody></table>
<p>索引为零（SHN_UNDEF）的节区头也存在，此索引标记的是未定义的节区引用。这一项的信息如下</p>
<p>正如之前所说，索引为零（SHN_UNDEF）的节区头也存在，此索引标记的是未定义的节区引用。这一项的信息如下</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sh_name</td>
<td>0</td>
<td>无名称</td>
</tr>
<tr>
<td>sh_type</td>
<td>SHT_NULL</td>
<td>限制</td>
</tr>
<tr>
<td>sh_flags</td>
<td>0</td>
<td>无标志</td>
</tr>
<tr>
<td>sh_addr</td>
<td>0</td>
<td>无地址</td>
</tr>
<tr>
<td>sh_offset</td>
<td>0</td>
<td>无文件偏移</td>
</tr>
<tr>
<td>sh_size</td>
<td>0</td>
<td>无大小</td>
</tr>
<tr>
<td>sh_link</td>
<td>SHN_UNDEF</td>
<td>无链接信息</td>
</tr>
<tr>
<td>sh_info</td>
<td>0</td>
<td>无辅助信息</td>
</tr>
<tr>
<td>sh_addralign</td>
<td>0</td>
<td>无对齐要求</td>
</tr>
<tr>
<td>sh_entsize</td>
<td>0</td>
<td>无表项</td>
</tr>
</tbody></table>
<h4 id="特殊下标"><a href="#特殊下标" class="headerlink" title="特殊下标"></a>特殊下标</h4><p>节头表中比较特殊的几个下标如下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SHN_UNDEF</td>
<td>0</td>
<td>标志未定义的，丢失的，不相关的或者其它没有意义的节引用。例如，与节号SHN_UNDEF相关的“定义”的符号就是一个未定义符号。<strong>注：虽然0号索引被保留用于未定义值，节头表仍然包含索引0的项。也就是说，如果ELF头的e_shnum为6，那么索引应该为0~5。更加详细的内容在后面会说明。</strong></td>
</tr>
<tr>
<td>SHN_LORESERVE</td>
<td>0xff00</td>
<td>保留索引值范围的下界。</td>
</tr>
<tr>
<td>SHN_LOPROC</td>
<td>0xff00</td>
<td>处理器相关的下界</td>
</tr>
<tr>
<td>SHN_HIPROC</td>
<td>0xff1f</td>
<td>处理器相关的上界</td>
</tr>
<tr>
<td>SHN_ABS</td>
<td>0xfff1</td>
<td>相关引用的绝对值。例如与节号SHN_ABS相关的符号拥有绝对值，它们不受重定位的影响</td>
</tr>
<tr>
<td>SHN_COMMON</td>
<td>0xfff2</td>
<td>这一节区相定义的符号是通用符号，例如FORTRAN COMMON，C语言中未分配的外部变量。</td>
</tr>
<tr>
<td>SHN_HIRESERVE</td>
<td>0xffff</td>
<td>保留索引值范围的上界。</td>
</tr>
</tbody></table>
<p><strong>系统保留在<code>SHN_LORESERVE</code>到<code>SHN_HIRESERVE</code>之间(包含边界)的索引值，这些值不在节头表中引用。也就是说，节头表不包含保留索引项。没特别理解。</strong></p>
<h4 id="部分节头字段"><a href="#部分节头字段" class="headerlink" title="部分节头字段"></a>部分节头字段</h4><h5 id="sh-type"><a href="#sh-type" class="headerlink" title="sh_type"></a>sh_type</h5><p>节类型目前有下列可选范围，其中 SHT 是<strong>Section Header Table</strong> 的简写。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SHT_NULL</td>
<td>0</td>
<td>该类型节区是非活动的，这种类型的节头中的其它成员取值无意义。</td>
</tr>
<tr>
<td>SHT_PROGBITS</td>
<td>1</td>
<td>该类型节区包含程序定义的信息，它的格式和含义都由程序来决定。</td>
</tr>
<tr>
<td>SHT_SYMTAB</td>
<td>2</td>
<td>该类型节区包含一个符号表（<strong>SYMbol TABle</strong>）。目前目标文件对每种类型的节区都只  能包含一个，不过这个限制将来可能发生变化。  一般，SHT_SYMTAB 节区提供用于链接编辑（指 ld  而言） 的符号，尽管也可用来实现动态链接。</td>
</tr>
<tr>
<td>SHT_STRTAB</td>
<td>3</td>
<td>该类型节区包含字符串表（ <strong>STRing TABle</strong> ）。</td>
</tr>
<tr>
<td>SHT_RELA</td>
<td>4</td>
<td>该类型节区包含显式指定位数的重定位项（ <strong>RELocation entry with Addends</strong> ），例如，32 位目标文件中的 Elf32_Rela 类型。此外，目标文件可能拥有多个重定位节区。</td>
</tr>
<tr>
<td>SHT_HASH</td>
<td>5</td>
<td>该类型节区包含符号哈希表（ <strong>HASH table</strong> ）。</td>
</tr>
<tr>
<td>SHT_DYNAMIC</td>
<td>6</td>
<td>该类型节区包含动态链接的信息（ <strong>DYNAMIC linking</strong> ）。</td>
</tr>
<tr>
<td>SHT_NOTE</td>
<td>7</td>
<td>该类型节区包含以某种方式标记文件的信息（<strong>NOTE</strong>）。</td>
</tr>
<tr>
<td>SHT_NOBITS</td>
<td>8</td>
<td>该类型节区不占用文件的空间，其它方面和SHT_PROGBITS相似。尽管该类型节区不包含任何字节，其对应的节头成员sh_offset 中还是会包含概念性的文件偏移。</td>
</tr>
<tr>
<td>SHT_REL</td>
<td>9</td>
<td>该类型节区包含重定位表项（<strong>RELocation entry without Addends</strong>），不过并没有指定位数。例如，32位目标文件中的 Elf32_rel 类型。目标文件中可以拥有多个重定位节区。</td>
</tr>
<tr>
<td>SHT_SHLIB</td>
<td>10</td>
<td>该类型此节区被保留，不过其语义尚未被定义。</td>
</tr>
<tr>
<td>SHT_DYNSYM</td>
<td>11</td>
<td>作为一个完整的符号表，它可能包含很多对动态链接而言不必  要的符号。因此，目标文件也可以包含一个 SHT_DYNSYM  节区，其中保存动态链接符号的一个最小集合，以节省空间。</td>
</tr>
<tr>
<td>SHT_LOPROC</td>
<td>0X70000000</td>
<td>此值指定保留给处理器专用语义的下界（ <strong>LOw PROCessor-specific semantics</strong> ）。</td>
</tr>
<tr>
<td>SHT_HIPROC</td>
<td>OX7FFFFFFF</td>
<td>此值指定保留给处理器专用语义的上界（ <strong>HIgh PROCessor-specific semantics</strong> ）。</td>
</tr>
<tr>
<td>SHT_LOUSER</td>
<td>0X80000000</td>
<td>此值指定保留给应用程序的索引下界。</td>
</tr>
<tr>
<td>SHT_HIUSER</td>
<td>0X8FFFFFFF</td>
<td>此值指定保留给应用程序的索引上界。</td>
</tr>
</tbody></table>
<h5 id="sh-flags"><a href="#sh-flags" class="headerlink" title="sh_flags"></a>sh_flags</h5><p>节头中 <code>sh_flags</code>  字段的每一个比特位都可以给出其相应的标记信息，其定义了对应的节区的内容是否可以被修改、被执行等信息。如果一个标志位被设置，则该位取值为1，未定义的位都为0。目前已定义值如下，其他值保留。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SHF_WRITE</td>
<td>0x1</td>
<td>这种节包含了进程运行过程中可以被写的数据。</td>
</tr>
<tr>
<td>SHF_ALLOC</td>
<td>0x2</td>
<td>这种节在进程运行时占用内存。对于不占用目标文件的内存镜像空间的某些控制节，该属性处于关闭状态(off)。</td>
</tr>
<tr>
<td>SHF_EXECINSTR</td>
<td>0x4</td>
<td>这种节包含可执行的机器指令（<strong>EXECutable INSTRuction</strong>）。</td>
</tr>
<tr>
<td>SHF_MASKPROC</td>
<td>0xf0000000</td>
<td>所有在这个掩码中的比特位用于特定处理器语义。</td>
</tr>
</tbody></table>
<h5 id="sh-link-amp-sh-info"><a href="#sh-link-amp-sh-info" class="headerlink" title="sh_link &amp; sh_info"></a>sh_link &amp; sh_info</h5><p>当节区类型的不同的时候，sh_link 和 sh_info 也会具有不同的含义。</p>
<table>
<thead>
<tr>
<th>sh_type</th>
<th>sh_link</th>
<th>sh_info</th>
</tr>
</thead>
<tbody><tr>
<td>SHT_DYNAMIC</td>
<td>节区中使用的字符串表的节头索引</td>
<td>0</td>
</tr>
<tr>
<td>SHT_HASH</td>
<td>此哈希表所使用的符号表的节头索引</td>
<td>0</td>
</tr>
<tr>
<td>SHT_REL/SHT_RELA</td>
<td>与符号表相关的的节头索引</td>
<td>重定位应用到的节的节头索引</td>
</tr>
<tr>
<td>SHT_SYMTAB/SHT_DYNSYM</td>
<td>操作系统特定信息，Linux 中的 ELF 文件中该项指向符号表中符号所对应的字符串节区在 Section Header Table 中的偏移。</td>
<td>操作系统特定信息</td>
</tr>
<tr>
<td>other</td>
<td><code>SHN_UNDEF</code></td>
<td>0</td>
</tr>
</tbody></table>
<h2 id="载入内核"><a href="#载入内核" class="headerlink" title="载入内核"></a>载入内核</h2><p>Linux下可以用<code>readelf</code>命令解析ELF文件，下面是我们在kernel目录下新添加的测试代码，因为是64位操作系统，编译命令需要如下修改，我们下一步就是将这个简单的elf文件加载入内核，物理内存中0x900是loader.bin的加载地址，其开始部分是不能覆盖的GDT，预计其大小是小于2000字节，保守起见这里选起始的物理地址为0x1500，所以链接命令指定虚拟起始地址0xc0001500。</p>
<p><strong>mian.c</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">	while(1);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--sudo gcc -m32 -c -o main.o main.c</span><br><span class="line">--sudo ld -m elf_i386 -Ttext 0xc0001500 -e main -o kernel.bin main.o</span><br><span class="line">--ll kernel.bin</span><br></pre></td></tr></table></figure>

<p>下面通过<code>dd</code>命令将其写入磁盘，为了不纠结count的赋值，这里直接赋值为200，seek赋值为9，写在第9扇区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--sudo dd if&#x3D;.&#x2F;kernel.bin of&#x3D;&#x2F;home&#x2F;fyz&#x2F;cx&#x2F;bochs-2.6.2&#x2F;hd60M.img bs&#x3D;512 count&#x3D;200 seek&#x3D;9 conv&#x3D;notrunc</span><br></pre></td></tr></table></figure>

<p>写完之后我们需要修改loader.S中的内容，分两步完成</p>
<ul>
<li>加载内核：内核文件加载到内存缓冲区</li>
<li>初始化内核：需要在分页后，将加载进来的elf内核文件安置到相应的虚拟内存地址，然后跳过去执行，从此loader的工作结束</li>
</ul>
<p>内核的加载地址选取的是<code>0x7e00~0x9fbff</code>范围中的0x70000，添加如下片断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; ------------------ 加载内核 ------------------</span><br><span class="line">mov eax, KERNEL_START_SECTOR  ; kernel.bin所在的扇区号0x9</span><br><span class="line">mov ebx, KERNEL_BIN_BASE_ADDR ; 0x70000</span><br><span class="line">; 从磁盘读出后,写入到ebx指定的地址</span><br><span class="line">mov ecx, 200 ; 读入的扇区数</span><br><span class="line"></span><br><span class="line">call rd_disk_m_32 ; eax,ebx,ecx均为参数,从硬盘上读取数据</span><br><span class="line"></span><br><span class="line">; 创建页目录及页表并初始化页内存位图</span><br><span class="line">call setup_page</span><br></pre></td></tr></table></figure>

<p>下一步是初始化内核的工作，我们需要遍历<code>kernel.bin</code>程序中所有的段，因为它们才是程序运行的实质指令和数据的所在地，然后将各段拷贝到自己被编译的虚拟地址中，如下添加的是在<code>loader.S</code>中的内容，注释已经很详细了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">   ; -------------------------   加载kernel  ----------------------</span><br><span class="line">   [略...]</span><br><span class="line">   ; 打开cr0的pg位(第31位)</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x80000000</span><br><span class="line">   mov cr0, eax</span><br><span class="line">   </span><br><span class="line">   ; 在开启分页后，用gdt新的地址重新加载</span><br><span class="line">   lgdt [gdt_ptr] ; 重新加载</span><br><span class="line">   </span><br><span class="line">   jmp SELECTOR_CODE:enter_kernel	  ; 强制刷新流水线,更新gdt,不刷新也可以</span><br><span class="line">enter_kernel:  </span><br><span class="line">   call kernel_init</span><br><span class="line">   mov esp, 0xc009f000     ;进入内核之后栈也要修改</span><br><span class="line">   jmp KERNEL_ENTRY_POINT  ; 用地址0x1500访问测试，结果ok</span><br><span class="line">;----------将kernel.bin中的segment拷贝到编译的地址----------</span><br><span class="line">kernel_init:</span><br><span class="line">   xor eax, eax</span><br><span class="line">   xor ebx, ebx	; 记录程序头表地址</span><br><span class="line">   xor ecx, ecx	; cx记录程序头表中的program header数量</span><br><span class="line">   xor edx, edx	; dx记录program header尺寸,即e_phentsize</span><br><span class="line">	</span><br><span class="line">   mov dx, [KERNEL_BIN_BASE_ADDR + 42] ; 偏移文件42字节处的属性是e_phentsize,表示program header大小</span><br><span class="line">   mov ebx, [KERNEL_BIN_BASE_ADDR + 28] ; 偏移文件开始部分28字节的地方是e_phoff,表示第1个program header在文件中的偏移量</span><br><span class="line"></span><br><span class="line">   add ebx, KERNEL_BIN_BASE_ADDR</span><br><span class="line">   mov cx, [KERNEL_BIN_BASE_ADDR + 44]    ; 偏移文件开始部分44字节的地方是e_phnum,表示有几个program header</span><br><span class="line">.each_segment:</span><br><span class="line">   cmp byte [ebx + 0], PT_NULL ; 若p_type等于 PT_NULL,说明此program header未使用。</span><br><span class="line">   je .PTNULL</span><br><span class="line">   </span><br><span class="line">   ;为函数memcpy压入参数,参数是从右往左依然压入.函数原型类似于 memcpy(dst,src,size)</span><br><span class="line">   push dword [ebx + 16] ; program header中偏移16字节的地方是p_filesz,压入函数memcpy的第三个参数:size</span><br><span class="line">   mov eax, [ebx + 4] ; 距程序头偏移量为4字节的位置是p_offset</span><br><span class="line">   add eax, KERNEL_BIN_BASE_ADDR	  ; 加上kernel.bin被加载到的物理地址,eax为该段的物理地址</span><br><span class="line">   push eax</span><br><span class="line">   push dword [ebx + 8] ; 压入函数memcpy的第一个参数:目的地址,偏移程序头8字节的位置是p_vaddr，这就是目的地址</span><br><span class="line">   call mem_cpy ; 调用mem_cpy完成段复制</span><br><span class="line">   add esp,12   ; 清理栈中压入的三个参数, 3 * 4 &#x3D; 12 字节</span><br><span class="line">.PTNULL:</span><br><span class="line">   add ebx, edx				  ; edx为program header大小,即e_phentsize,在此ebx指向下一个program header </span><br><span class="line">   loop .each_segment</span><br><span class="line">   ret</span><br><span class="line">   </span><br><span class="line">;----------  逐字节拷贝 mem_cpy(dst,src,size) ------------</span><br><span class="line">;输入:栈中三个参数(dst,src,size)</span><br><span class="line">;输出:无</span><br><span class="line">;---------------------------------------------------------</span><br><span class="line">mem_cpy:</span><br><span class="line">	cld ; 控制重复字符递增方式,也就是edi和esi每复制一次就加一个单位大小,相对的指令为std</span><br><span class="line">	push ebp</span><br><span class="line">	mov esp, ebp</span><br><span class="line">	push ecx ; rep指令用到了ecx，但ecx对于外层段的循环还有用，故先入栈备份</span><br><span class="line">	mov edi, [ebp + 8]  ; dst</span><br><span class="line">	mov esi, [ebp + 12] ; src</span><br><span class="line">	mov ecx, [ebp + 16] ; size</span><br><span class="line">	rep movsb ; 逐字节拷贝,直到ecx为0</span><br><span class="line">	</span><br><span class="line">	; 恢复环境</span><br><span class="line">	pop ecx</span><br><span class="line">	pop ebp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>最终的一个内存布局如下，参考之前的1MB实模式地址图来对应就明白了</p>
<p><img src="https://thunderjie.github.io/2020/05/10/%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0-part-1/43.png" alt="img"> </p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结:"></a>小总结:</h3><p>修改一些文件所在目录 增加一个 <strong>boot</strong> 来放 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── boot</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── boot.inc</span><br><span class="line">│   ├── loader.bin</span><br><span class="line">│   ├── loader.S</span><br><span class="line">│   ├── mbr.bin</span><br><span class="line">│   └── mbr.S</span><br></pre></td></tr></table></figure>

<h4 id="boot-inc"><a href="#boot-inc" class="headerlink" title="boot.inc"></a>boot.inc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">;---------------------------loader和kernel-------------</span><br><span class="line">LOADER_BASE_ADDR equ 0x900</span><br><span class="line">LOADER_START_SECTOR equ 0x2</span><br><span class="line">PAGE_DIR_TABLE_POS equ 0x100000</span><br><span class="line">KERNEL_START_SECTOR equ 0x9</span><br><span class="line">KERNEL_BIN_BASE_ADDR equ 0x70000</span><br><span class="line">KERNEL_ENTRY_POINT equ 0xc0001500</span><br><span class="line"></span><br><span class="line">; gdt描述符属性</span><br><span class="line">; 段描述符高23位，表示段界限的粒度为4KB</span><br><span class="line">DESC_G_4K equ 100000000000000000000000b   </span><br><span class="line"></span><br><span class="line">; D&#x2F;B为，1表示运行在32位模式下</span><br><span class="line">DESC_D_32 equ 10000000000000000000000b</span><br><span class="line">; 高21位，如果为1表示为64位代码段，目前我们都是在32位模式下操作，故为零</span><br><span class="line">DESC_L equ     0000000000000000000000b</span><br><span class="line">; 没有明确的用途，取值随意</span><br><span class="line">DESC_AVL equ   000000000000000000000b</span><br><span class="line">; 第二部分段界限值，由于采用了32位平坦模型，所以段界限为(4GB &#x2F; 4KB) - 1 &#x3D; 0xFFFFF，故为全1</span><br><span class="line">DESC_LIMIT_CODE2 equ 11110000000000000000b</span><br><span class="line">DESC_LIMIT_DATA2 equ DESC_LIMIT_CODE2</span><br><span class="line">; 书中取全零，怀疑是错误的，因为保护模式的基地址是0xb8000，所以最后8位应该是b，而不是0</span><br><span class="line">DESC_LIMIT_VIDEO2 equ 00000000000000000000000000001011b</span><br><span class="line">DESC_P equ 1000000000000000b</span><br><span class="line">DESC_DPL_0 equ 000000000000000b</span><br><span class="line">DESC_DPL_1 equ 010000000000000b</span><br><span class="line">DESC_DPL_2 equ 100000000000000b</span><br><span class="line">DESC_DPL_3 equ 110000000000000b</span><br><span class="line">DESC_S_CODE equ  1000000000000b</span><br><span class="line">DESC_S_DATA equ  DESC_S_CODE</span><br><span class="line">DESC_S_sys equ  0000000000000b</span><br><span class="line">DESC_TYPE_CODE equ 100000000000b</span><br><span class="line">DESC_TYPE_DATA equ 001000000000b</span><br><span class="line"></span><br><span class="line">; 代码段描述符的高32位表示，其中(0x00 &lt;&lt; 24表示最高8位的段基址值，由于我们采用的是平坦模型，故基址为零)，后面唯一可变的就是段界限值</span><br><span class="line">DESC_CODE_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + \</span><br><span class="line">    DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + \</span><br><span class="line">    DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00</span><br><span class="line"></span><br><span class="line">DESC_DATA_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + \</span><br><span class="line">    DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + \</span><br><span class="line">    DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00</span><br><span class="line"></span><br><span class="line">DESC_VIDEO_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + \</span><br><span class="line">    DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + \</span><br><span class="line">    DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00</span><br><span class="line"></span><br><span class="line">; 选择字属性</span><br><span class="line">RPL0 equ 00b</span><br><span class="line">RPL1 equ 01b</span><br><span class="line">RPL2 equ 10b</span><br><span class="line">RPL3 equ 11b</span><br><span class="line">TI_GDT equ 000b</span><br><span class="line">TI_LDT equ 100b</span><br><span class="line"></span><br><span class="line">; 页表相关属性</span><br><span class="line">PG_P equ 1b</span><br><span class="line">PG_RW_R equ 00b</span><br><span class="line">PG_RW_W equ 10b</span><br><span class="line">PG_US_S equ 000b</span><br><span class="line">PG_US_U equ 100b</span><br><span class="line"></span><br><span class="line">PT_NULL equ 0</span><br></pre></td></tr></table></figure>

<h4 id="mbr-S"><a href="#mbr-S" class="headerlink" title="mbr.S"></a>mbr.S</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">%include &quot;boot.inc&quot; </span><br><span class="line">SECTION MBR vstart&#x3D;0x7c00</span><br><span class="line">	mov ax,cs</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov fs,ax</span><br><span class="line">	mov sp,0x7c00	</span><br><span class="line">	mov ax,0xb800	</span><br><span class="line">	mov gs,ax	</span><br><span class="line"></span><br><span class="line">	mov ax,0x600</span><br><span class="line">	mov bx,0x700</span><br><span class="line">	mov cx,0</span><br><span class="line">	mov dx,0x184f</span><br><span class="line">	int 0x10</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x00],&#39;1&#39;</span><br><span class="line">	mov byte [gs:0x01],0xA4 ;</span><br><span class="line">	mov byte [gs:0x02],&#39; &#39;</span><br><span class="line">	mov byte [gs:0x03],0xA4</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x04],&#39;M&#39;</span><br><span class="line">	mov byte [gs:0x05],0xA4</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x06],&#39;B&#39;</span><br><span class="line">	mov byte [gs:0x07],0xA4</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x08],&#39;R&#39;</span><br><span class="line">	mov byte [gs:0x09],0xA4</span><br><span class="line"></span><br><span class="line">	mov eax,LOADER_START_SECTOR</span><br><span class="line">	mov bx,LOADER_BASE_ADDR</span><br><span class="line">	mov cx,4</span><br><span class="line">	call rd_disk_m_16</span><br><span class="line"></span><br><span class="line">	jmp LOADER_BASE_ADDR + 0x300</span><br><span class="line"></span><br><span class="line">rd_disk_m_16:</span><br><span class="line">	mov esi,eax</span><br><span class="line">	mov di,cx</span><br><span class="line"></span><br><span class="line">	mov dx,0x1f2</span><br><span class="line">	mov al,cl</span><br><span class="line">	out dx,al</span><br><span class="line"></span><br><span class="line">	mov eax,esi</span><br><span class="line">	</span><br><span class="line">	mov dx,0x1f3</span><br><span class="line">	out dx,al</span><br><span class="line"></span><br><span class="line">	mov cl,8</span><br><span class="line">	shr eax,cl</span><br><span class="line">	mov dx,0x1f4</span><br><span class="line">	out dx,al</span><br><span class="line">	</span><br><span class="line">	shr eax,cl</span><br><span class="line">	mov dx,0x1f5</span><br><span class="line">	out dx,al</span><br><span class="line"></span><br><span class="line">	shr eax,cl</span><br><span class="line">	and al,0x0f</span><br><span class="line">	or al,0xe0</span><br><span class="line">	mov dx,0x1f6</span><br><span class="line">	out dx,al</span><br><span class="line"></span><br><span class="line">	mov dx,0x1f7</span><br><span class="line">	mov al,0x20</span><br><span class="line">	out dx,al</span><br><span class="line"></span><br><span class="line">.not_ready:</span><br><span class="line">	nop</span><br><span class="line">	in al,dx</span><br><span class="line">	and al,0x88</span><br><span class="line">	cmp al,0x08</span><br><span class="line">	jnz .not_ready</span><br><span class="line"></span><br><span class="line">	mov ax,di</span><br><span class="line">	mov dx,256</span><br><span class="line">	mul dx</span><br><span class="line">	mov cx,ax</span><br><span class="line">	mov dx,0x1f0</span><br><span class="line"></span><br><span class="line">.go_on_read:</span><br><span class="line">	in ax,dx</span><br><span class="line">	mov [bx],ax</span><br><span class="line">	add bx,2</span><br><span class="line">	loop .go_on_read</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure>

<h4 id="loader-S"><a href="#loader-S" class="headerlink" title="loader.S"></a>loader.S</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line"></span><br><span class="line">section loader vstart&#x3D;LOADER_BASE_ADDR</span><br><span class="line">LOADER_STACK_TOP equ LOADER_BASE_ADDR</span><br><span class="line"></span><br><span class="line">; 这里其实就是GDT的起始地址，第一个描述符为空</span><br><span class="line">GDT_BASE: dd 0x00000000</span><br><span class="line">          dd 0x00000000</span><br><span class="line"></span><br><span class="line">; 代码段描述符，一个dd为4字节，段描述符为8字节，上面为低4字节</span><br><span class="line">CODE_DESC: dd 0x0000FFFF</span><br><span class="line">           dd DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line">; 栈段描述符，和数据段共用</span><br><span class="line">DATA_STACK_DESC: dd 0x0000FFFF</span><br><span class="line">                 dd DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line">; 显卡段，非平坦</span><br><span class="line">VIDEO_DESC: dd 0x80000007</span><br><span class="line">            dd DESC_VIDEO_HIGH4</span><br><span class="line"></span><br><span class="line">GDT_SIZE equ $ - GDT_BASE</span><br><span class="line">GDT_LIMIT equ GDT_SIZE - 1</span><br><span class="line">times 120 dd 0</span><br><span class="line">SELECTOR_CODE equ (0x0001 &lt;&lt; 3) + TI_GDT + RPL0</span><br><span class="line">SELECTOR_DATA equ (0x0002 &lt;&lt; 3) + TI_GDT + RPL0</span><br><span class="line">SELECTOR_VIDEO equ (0x0003 &lt;&lt; 3) + TI_GDT + RPL0</span><br><span class="line"></span><br><span class="line">; 内存大小，单位字节，此处的内存地址是0xb00</span><br><span class="line">total_memory_bytes dd 0</span><br><span class="line"></span><br><span class="line">gdt_ptr dw GDT_LIMIT</span><br><span class="line">        dd GDT_BASE</span><br><span class="line"></span><br><span class="line">ards_buf times 244 db 0</span><br><span class="line">ards_nr dw 0</span><br><span class="line"></span><br><span class="line">loader_start: </span><br><span class="line"></span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    mov edx, 0x534d4150</span><br><span class="line">    mov di, ards_buf</span><br><span class="line"></span><br><span class="line">.e820_mem_get_loop:</span><br><span class="line">    mov eax, 0x0000e820</span><br><span class="line">    mov ecx, 20</span><br><span class="line">    int 0x15</span><br><span class="line">    </span><br><span class="line">    jc .e820_mem_get_failed</span><br><span class="line">    </span><br><span class="line">    add di, cx</span><br><span class="line">    inc word [ards_nr]</span><br><span class="line">    cmp ebx, 0</span><br><span class="line">    jnz .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line">    mov cx, [ards_nr]</span><br><span class="line">    mov ebx, ards_buf</span><br><span class="line">    xor edx, edx</span><br><span class="line"></span><br><span class="line">.find_max_mem_area:</span><br><span class="line">    mov eax, [ebx]</span><br><span class="line">    add eax, [ebx + 8]</span><br><span class="line">    add ebx, 20</span><br><span class="line">    cmp edx, eax</span><br><span class="line">    jge .next_ards</span><br><span class="line">    mov edx, eax</span><br><span class="line"></span><br><span class="line">.next_ards:</span><br><span class="line">    loop .find_max_mem_area</span><br><span class="line">    jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">.e820_mem_get_failed:</span><br><span class="line">    mov byte [gs:0], &#39;f&#39;</span><br><span class="line">    mov byte [gs:2], &#39;a&#39;</span><br><span class="line">    mov byte [gs:4], &#39;i&#39;</span><br><span class="line">    mov byte [gs:6], &#39;l&#39;</span><br><span class="line">    mov byte [gs:8], &#39;e&#39;</span><br><span class="line">    mov byte [gs:10], &#39;d&#39;</span><br><span class="line">    ; 内存检测失败，不再继续向下执行</span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">.mem_get_ok:</span><br><span class="line">    mov [total_memory_bytes], edx</span><br><span class="line"></span><br><span class="line">    ; 开始进入保护模式</span><br><span class="line">    ; 打开A20地址线</span><br><span class="line">    in al, 0x92</span><br><span class="line">    or al, 00000010B</span><br><span class="line">    out 0x92, al</span><br><span class="line"></span><br><span class="line">    ; 加载gdt</span><br><span class="line">    lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">    ; cr0第0位置1</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    or eax, 0x00000001</span><br><span class="line">    mov cr0, eax</span><br><span class="line"></span><br><span class="line">    ; 刷新流水线</span><br><span class="line">    jmp dword SELECTOR_CODE:p_mode_start</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">    mov ax, SELECTOR_DATA</span><br><span class="line">    mov ds, ax</span><br><span class="line"></span><br><span class="line">    mov es, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line"></span><br><span class="line">    mov esp, LOADER_STACK_TOP</span><br><span class="line">    mov ax, SELECTOR_VIDEO</span><br><span class="line">    mov gs, ax</span><br><span class="line"></span><br><span class="line">    ; 加载kernel</span><br><span class="line">    mov eax, KERNEL_START_SECTOR</span><br><span class="line">    mov ebx, KERNEL_BIN_BASE_ADDR</span><br><span class="line">    mov ecx, 200</span><br><span class="line"></span><br><span class="line">    call rd_disk_m_32</span><br><span class="line">    </span><br><span class="line">    call setup_page</span><br><span class="line"></span><br><span class="line">    ; 保存gdt表</span><br><span class="line">    sgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">    ; 重新设置gdt描述符， 使虚拟地址指向内核的第一个页表</span><br><span class="line">    mov ebx, [gdt_ptr + 2]</span><br><span class="line">    or dword [ebx + 0x18 + 4], 0xc0000000</span><br><span class="line">    add dword [gdt_ptr + 2], 0xc0000000</span><br><span class="line">    </span><br><span class="line">    add esp, 0xc0000000</span><br><span class="line"></span><br><span class="line">    ; 页目录基地址寄存器</span><br><span class="line">    mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">    mov cr3, eax</span><br><span class="line"></span><br><span class="line">    ; 打开分页</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    or eax, 0x80000000</span><br><span class="line">    mov cr0, eax</span><br><span class="line"></span><br><span class="line">    lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">    ; 初始化kernel</span><br><span class="line">    jmp SELECTOR_CODE:enter_kernel</span><br><span class="line"></span><br><span class="line">    enter_kernel:</span><br><span class="line">        call kernel_init</span><br><span class="line">        mov esp, 0xc009f000</span><br><span class="line">        jmp KERNEL_ENTRY_POINT</span><br><span class="line"></span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">; 创建页目录以及页表</span><br><span class="line">setup_page:</span><br><span class="line">    ; 页目录表占据4KB空间，清零之</span><br><span class="line">    mov ecx, 4096</span><br><span class="line">    mov esi, 0</span><br><span class="line">.clear_page_dir:   </span><br><span class="line">    mov byte [PAGE_DIR_TABLE_POS + esi], 0</span><br><span class="line">    inc esi</span><br><span class="line">    loop .clear_page_dir</span><br><span class="line"></span><br><span class="line">; 创建页目录表(PDE)</span><br><span class="line">.create_pde:</span><br><span class="line">    mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">    ; 0x1000为4KB，加上页目录表起始地址便是第一个页表的地址</span><br><span class="line">    add eax, 0x1000</span><br><span class="line">    mov ebx, eax</span><br><span class="line"></span><br><span class="line">    ; 设置页目录项属性</span><br><span class="line">    or eax, PG_US_U | PG_RW_W | PG_P</span><br><span class="line">    ; 设置第一个页目录项</span><br><span class="line">    mov [PAGE_DIR_TABLE_POS], eax</span><br><span class="line">    ; 第768(内核空间的第一个)个页目录项，与第一个相同，这样第一个和768个都指向低端4MB空间</span><br><span class="line">    mov [PAGE_DIR_TABLE_POS + 0xc00], eax</span><br><span class="line">    ; 最后一个表项指向自己，用于访问页目录本身</span><br><span class="line">    sub eax, 0x1000</span><br><span class="line">    mov [PAGE_DIR_TABLE_POS + 4092], eax</span><br><span class="line"></span><br><span class="line">; 创建页表</span><br><span class="line">    mov ecx, 256</span><br><span class="line">    mov esi, 0</span><br><span class="line">    mov edx, PG_US_U | PG_RW_W | PG_P</span><br><span class="line">.create_pte:</span><br><span class="line">    mov [ebx + esi * 4], edx</span><br><span class="line">    add edx, 4096</span><br><span class="line">    inc esi</span><br><span class="line">    loop .create_pte</span><br><span class="line"></span><br><span class="line">; 创建内核的其它PDE</span><br><span class="line">    mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">    add eax, 0x2000</span><br><span class="line">    or eax, PG_US_U | PG_RW_W | PG_P</span><br><span class="line">    mov ebx, PAGE_DIR_TABLE_POS</span><br><span class="line">    mov ecx, 254</span><br><span class="line">    mov esi, 769</span><br><span class="line">.create_kernel_pde:</span><br><span class="line">    mov [ebx + esi * 4], eax</span><br><span class="line">    inc esi</span><br><span class="line">    add eax, 0x1000</span><br><span class="line">    loop .create_kernel_pde</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">; 保护模式的硬盘读取函数</span><br><span class="line">rd_disk_m_32:</span><br><span class="line"></span><br><span class="line">    mov esi, eax</span><br><span class="line">    mov di, cx</span><br><span class="line"></span><br><span class="line">    mov dx, 0x1f2</span><br><span class="line">    mov al, cl</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    mov eax, esi</span><br><span class="line">    ; 保存LBA地址</span><br><span class="line">    mov dx, 0x1f3</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    mov cl, 8</span><br><span class="line">    shr eax, cl</span><br><span class="line">    mov dx, 0x1f4</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    shr eax, cl</span><br><span class="line">    mov dx, 0x1f5</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    shr eax, cl</span><br><span class="line">    and al, 0x0f</span><br><span class="line">    or al, 0xe0</span><br><span class="line">    mov dx, 0x1f6</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    mov dx, 0x1f7</span><br><span class="line">    mov al, 0x20</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">.not_ready:</span><br><span class="line">    nop</span><br><span class="line">    in al, dx</span><br><span class="line">    and al, 0x88</span><br><span class="line">    cmp al, 0x08</span><br><span class="line">    jnz .not_ready</span><br><span class="line"></span><br><span class="line">    mov ax, di</span><br><span class="line">    mov dx, 256</span><br><span class="line">    mul dx</span><br><span class="line">    mov cx, ax</span><br><span class="line">    mov dx, 0x1f0</span><br><span class="line"></span><br><span class="line">.go_on_read:</span><br><span class="line">    in ax, dx</span><br><span class="line">    mov [ds:ebx], ax</span><br><span class="line">    add ebx, 2</span><br><span class="line">    loop .go_on_read</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">kernel_init:</span><br><span class="line">    xor eax, eax</span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    xor ecx, ecx</span><br><span class="line">    xor edx, edx</span><br><span class="line"></span><br><span class="line">    mov dx, [KERNEL_BIN_BASE_ADDR + 42]</span><br><span class="line">    mov ebx, [KERNEL_BIN_BASE_ADDR + 28]</span><br><span class="line"></span><br><span class="line">    add ebx, KERNEL_BIN_BASE_ADDR</span><br><span class="line">    mov cx, [KERNEL_BIN_BASE_ADDR + 44]</span><br><span class="line"></span><br><span class="line">.each_segment:</span><br><span class="line">    cmp byte [ebx], PT_NULL</span><br><span class="line">    je .PTNULL</span><br><span class="line"></span><br><span class="line">    ; 准备mem_cpy参数</span><br><span class="line">    push dword [ebx + 16]</span><br><span class="line">    mov eax, [ebx + 4]</span><br><span class="line">    add eax, KERNEL_BIN_BASE_ADDR</span><br><span class="line">    push eax</span><br><span class="line">    push dword [ebx + 8]</span><br><span class="line"></span><br><span class="line">    call mem_cpy</span><br><span class="line">    add esp, 12</span><br><span class="line"></span><br><span class="line">.PTNULL:</span><br><span class="line">    add ebx, edx</span><br><span class="line">    loop .each_segment</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">mem_cpy:</span><br><span class="line">    cld</span><br><span class="line">    push ebp</span><br><span class="line">    mov ebp, esp</span><br><span class="line">    push ecx</span><br><span class="line"></span><br><span class="line">    mov edi, [ebp + 8]</span><br><span class="line">    mov esi, [ebp + 12]</span><br><span class="line">    mov ecx, [ebp + 16]</span><br><span class="line">    rep movsb</span><br><span class="line"></span><br><span class="line">    pop ecx</span><br><span class="line">    pop ebp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>实行的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">编译</span><br><span class="line">--sudo nasm -I include&#x2F; -o mbr.bin mbr.asm</span><br><span class="line">--sudo nasm -I include&#x2F; -o loader.bin loader.asm</span><br><span class="line"></span><br><span class="line">下面将生成的 mbr.bin 写入我们的虚拟硬盘，还是用 dd 命令。</span><br><span class="line">--sudo dd if&#x3D;&#x2F;your_path&#x2F;mbr.bin of&#x3D;&#x2F;your_path&#x2F;bochs&#x2F;hd60M.img bs&#x3D;512 count&#x3D;1 conv&#x3D;notrunc</span><br><span class="line">--sudo dd if&#x3D;&#x2F;home&#x2F;fyz&#x2F;sc&#x2F;bochs-2.6.2&#x2F;boot&#x2F;mbr.bin of&#x3D;&#x2F;home&#x2F;fyz&#x2F;sc&#x2F;bochs-2.6.2&#x2F;hd60M.img bs&#x3D;512 count&#x3D;1 conv&#x3D;notrunc</span><br><span class="line"></span><br><span class="line">将生成的 loader.bin 写入硬盘第 2 个扇区。第 0 个扇区是 MBR，第 1 个扇区是空的未使用。（ 我就喜欢 你咋的</span><br><span class="line">--sudo dd if&#x3D;.&#x2F;loader.bin of&#x3D;&#x2F;your_path&#x2F;bochs&#x2F;hd60M.img bs&#x3D;512 count&#x3D;4 seek&#x3D;2 conv&#x3D;notrunc</span><br><span class="line">--sudo dd if&#x3D;.&#x2F;loader.bin of&#x3D;&#x2F;home&#x2F;fyz&#x2F;sc&#x2F;bochs-2.6.2&#x2F;hd60M.img bs&#x3D;512 count&#x3D;4 seek&#x3D;2 conv&#x3D;notrunc</span><br></pre></td></tr></table></figure>



<h2 id="特权级深入浅出"><a href="#特权级深入浅出" class="headerlink" title="特权级深入浅出"></a>特权级深入浅出</h2><h3 id="特权级简介"><a href="#特权级简介" class="headerlink" title="特权级简介"></a>特权级简介</h3><p>特权级按照权力从大到小分为 0、1、2、3 级，没错，数字越小，权力越大，<strong>0 级特权能力最大，3 级特权能力最小</strong>。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601894/0" alt="image-20201201111343825"> </p>
<p>操作系统位于最内环的 0 级特权，它要直接控制硬件，掌控各种核心数据，所以它的权利必须最大。系统程序分别位于 1 级特权和 2 级特权，运行在这两层的程序一般是虚拟机、驱 动程序等系统服务。在最外层的是 3 级特权，我们的用户程序就运行在此层，用户程序被设计为“有需求时找操作系统”，所以它不需要太大的能力，能完成一般工作即可，因此它的权利最弱。</p>
<h3 id="TSS-简介"><a href="#TSS-简介" class="headerlink" title="TSS 简介"></a>TSS 简介</h3><p><strong>任务状态段</strong>（Task-State Segment(<strong>TSS</strong>)），保存任务状态信息的系统段为任务状态段。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13190601914/0" alt="image-20201201112920210"> </p>
<p>TSS 是一种数据结构，它用于存储任务的环境。TSS主要分为<strong>动态字段和静态字段</strong>。</p>
<blockquote>
<p>在任务切换过程中当任务挂起时，处理器会更新动态字段，动态字段有：<br> （1）通用寄存器字段—任务切换之前，EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI寄存器状态。<br> （2）段选择符字段—任务切换之前，ES,CS,SS,DS,FS,GS寄存器保存的段选择符。<br> （3）EFLAGS寄存器字段—任务切换之前，EFAGS寄存器的状态。<br> （4）EIP字段—任务切换之前，EIP寄存器的状态。<br> （5）先前任务链接字段—包含先前任务的TSS的段选择符。该字段禁止任务通过使用IRET指令返回先前的任务。</p>
<p>当任务创建时会创建静态字段，静态字段可读，不可写：<br> （1）LDT段选择符字段—包含任务LDT的段选择符。<br> （2）CR3控制寄存器字段—包含任务使用的页目录的物理基地址。CR3也被称为page directory base register(PDBR)页目录基址寄存器。<br> （3）特权级0,1,2栈指针字段—包含栈段（因为任务运行在不同特权级下，需要不同的栈段，故相应的SS0，SS1，SS2）的段选择符的逻辑地址和栈的偏移（不同特权级相应的ESP0，ESP1，ESP2）。在特定的任务中该字段是静态的，但是如果栈切换发生在单个任务中，SS和EIP的值就会改变。<br> （4）T标志（调试陷阱，100字节，位0）—如果设置，当切换任务时，会引起调试异常。<br> （5）I/O映射基址字段—是16位的偏移，包含从I/O权限位图和中断导向表中TSS的基地址。</p>
</blockquote>
<p>TSS 是每个任务都有的结构，它用于一个任务的标识，相当于<strong>任务的身份证</strong>，程序拥有此结构才能运行，这是处理器硬件上用于任务管理的系统结构，处理器能够识别其中每一个字段。该结构看上去也有点复杂，里面众多寄存器都囊括到这 104 字节中啦，其实这 104 字节只是 TSS 的最小尺寸（其中有很多寄存器信息，<strong>而TSS则是由TR寄存器加载的</strong>），根据需要，还可以再接上个 IO 位图，这些内容将在后面章节用到时补充。这里目前只需要关注 28 字节之下的部分，这里包括了 3 个栈指针。</p>
<p>每个特权级只能有一个栈，特权级在变换的时候需要用到不同特权级下的栈，特权转移分为两类，一类是中断门和调用门实现低权限到高权限，另一类是由调用返回指令从高权限到低权限，这是唯一一种让处理器降低权限的方法。</p>
<p>对于低权限到高权限的情况，处理器需要提前记录目标栈的地方，更新SS和ESP，也就是说我们只需要提前在TSS中记录好高特权级的栈地址即可，也就是说TSS不需要记录3级特权的栈，因为它的权限最低。</p>
<p>对于高权限到低权限的情况，一方面因为处理器不需要在TSS中寻找低特权级目标栈的，也就是说TSS也不需要记录3级特权的栈，另一方面因为低权限的栈地址已经存在了，这是由处理器的向高特权级转移指令(int、call等)实现机制决定的。</p>

      
      <!-- reward -->
      
      <div id="reward-btn">
        Reward
      </div>
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>Copyright： </strong>
              Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://yoursite.com/2021/02/21/cx3/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/" rel="tag">操作系统真象还原</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2021/02/21/cx5/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            操作系统真象还原&lt;第五部分&gt;
          
        </div>
      </a>
    
    
      <a href="/2021/01/02/hb/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">汇编部分总结</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2021
        John Doe
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['你努力，剩下的交给我', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>




<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>





<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>


    
  </div>
</body>

</html>